<!DOCTYPE html>

<html lang="zh-TW">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>3D模型切片器（切片內零件獨立視覺＋座標HUD）</title>

<!-- Three.js r128 UMD -->

<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/libs/fflate.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js"></script>

<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>

<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/3MFLoader.js"></script>

<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<style>
  body,html{margin:0;padding:0;height:100%;}
  body{
    font-family:"Microsoft JhengHei", Arial, system-ui, -apple-system;
    display:flex;
    flex-direction:column;
    height:100vh;
    background:#f8fafc;
  }
  .header{background:#1f2937; color:#fff; padding:12px; text-align:center;}
  .main{flex:1; display:flex; overflow:hidden;}
  .panel{
    width:420px;
    padding:12px;
    background:#ecf0f1;
    border-right:1px solid #cbd5e1;
    overflow:auto;
    box-sizing:border-box;
  }
  .controls .panel-title{font-weight:700; margin:10px 0 8px; color:#1f2937; font-size:15px;}
  input, select, button{
    width:100%;
    padding:8px;
    margin-bottom:8px;
    box-sizing:border-box;
    font-size:14px;
  }
  input[type="range"]{ padding:0; }
  .small-btns{display:flex; gap:8px;}
  .small-btns button{flex:1;}
  .note{font-size:12px; color:#64748b; line-height:1.5;}
  .viewer{flex:1; display:flex; flex-direction:column; background:#fff;}
  .tabs{display:flex; border-bottom:1px solid #e2e8f0;}
  .tab{padding:8px 12px; cursor:pointer; background:#eef2f7; user-select:none;}
  .tab.active{background:#fff;}
  .canvas-wrap{position:relative; flex:1; background:#fff;}
  canvas#model-canvas{width:100%; height:100%; display:block;}
  canvas#slice-canvas{
    position:absolute; left:50%; top:50%;
    transform:translate(-50%,-50%);
    display:none; background:transparent;
  }
  #layer-slider{
    position:absolute; left:50%; bottom:10px; transform:translateX(-50%);
    min-width:40%; max-width:80%;
    display:none; z-index:5; background:rgba(255,255,255,0.9);
    border:1px solid #e2e8f0; border-radius:6px; padding:2px 4px;
  }
  .layers-list{
    max-height:240px; overflow:auto;
    border:1px solid #e2e8f0; background:#fff;
    padding:0; margin:6px 0; border-radius:6px;
  }
  .layer-item{
    display:flex; align-items:center; justify-content:space-between;
    padding:6px 8px; border-bottom:1px solid #eef2f7;
    cursor:pointer; gap:8px;
  }
  .layer-item:last-child{border-bottom:none;}
  .layer-item.active{background:#dbeafe;}
  .layer-left{display:flex; align-items:center; gap:8px; min-width:0;}
  .layer-title{font-size:13px; color:#334155; white-space:nowrap;}
  .layer-right{display:flex; align-items:center; gap:6px;}
  .swatch-wrap{position:relative; width:18px; height:18px; flex:0 0 auto;}
  .color-swatch{
    width:18px; height:18px;
    border-radius:3px; border:1px solid #94a3b8;
    image-rendering:pixelated; display:block;
  }
  .color-input-overlay{
    position:absolute; left:0; top:0;
    width:100%; height:100%;
    opacity:0; pointer-events:auto; border:none; padding:0; background:transparent;
  }
  .layer-meta{font-size:11px; color:#64748b; white-space:nowrap;}
  .pill{
    display:inline-block; border-radius:12px; padding:2px 8px;
    font-size:12px; background:#f1f5f9; color:#334155;
    border:1px solid #e2e8f0; margin-bottom:8px;
  }
  .help{font-size:12px; color:#5f6b7a; line-height:1.45; margin-top:-4px; margin-bottom:8px;}
  hr.sep{border:none; border-top:1px dashed #cbd5e1; margin:10px 0 6px;}
  .form-row{display:flex; gap:10px; align-items:center; margin-top:6px; flex-wrap:wrap;}
  .form-row .chk{
    display:flex; align-items:center; gap:6px;
    padding:6px 8px; background:#fff;
    border:1px solid #d1d5db; border-radius:6px; white-space:nowrap;
  }
  .form-row input[type="checkbox"]{width:auto; margin:0;}
  .hint{font-size:12px; color:#475569; margin-top:-6px; margin-bottom:8px;}
  .muted{color:#64748b}
  .row{display:flex; gap:8px;}
  .row > *{flex:1}
  .axis-badge{display:inline-flex; align-items:center; gap:6px; font-size:12px; margin:-4px 0 6px 0;}
  .dot{width:10px; height:10px; border-radius:50%;}
  .dot.x{background:#ef4444;}
  .dot.y{background:#22c55e;}
  .dot.z{background:#3b82f6;}

  .progress{
    position:fixed; left:50%; bottom:22px; transform:translateX(-50%);
    background:rgba(17,24,39,0.92); color:#fff; z-index:9999;
    padding:10px 14px; border-radius:10px; min-width:280px;
    box-shadow:0 12px 30px rgba(0,0,0,.25); display:none;
  }
  .progress .title{font-size:13px; margin-bottom:6px; opacity:.9}
  .progress .bar{width:100%; height:10px; background:#334155; border-radius:6px; overflow:hidden}
  .progress .bar > span{display:block; height:100%; width:0%; background:#38bdf8; transition:width .12s ease}
  .progress .percent{font-size:12px; text-align:right; margin-top:6px; opacity:.85}

  .badge-select{
    display:inline-block; padding:4px 8px; font-size:12px;
    border-radius:8px; background:#f1f5f9;
    border:1px solid #e5e7eb; color:#334155;
    margin-top:-6px; margin-bottom:8px;
  }
  .marquee{
    position:absolute; border:1px dashed #2563eb;
    background:rgba(59,130,246,.12);
    pointer-events:none; display:none; z-index:7;
  }
  .box-toggle{
    position:absolute; left:12px; top:12px; z-index:8;
    width:auto; padding:6px 10px; border-radius:8px;
    border:1px solid #1d4ed8; background:#2563eb;
    color:#fff; cursor:pointer;
    box-shadow:0 4px 12px rgba(0,0,0,.15); opacity:.95;
  }
  .box-toggle:hover{opacity:1}
  .box-toggle.active{background:#1e40af; border-color:#1e40af;}
  .box-toggle.hidden{display:none;}
  .canvas-wrap.select-mode{cursor:crosshair;}

  /* 切片視圖：零件視覺設定浮窗 */
  .part-fly{
    position:absolute; right:12px; top:12px; z-index:9;
    width:280px; padding:10px;
    border:1px solid #cbd5e1; border-radius:10px;
    background:#ffffff; box-shadow:0 10px 24px rgba(0,0,0,.12);
    display:none;
  }
  .part-fly .title{font-weight:700; font-size:14px; color:#0f172a; margin-bottom:6px;}
  .part-fly .close{
    position:absolute; right:8px; top:8px;
    border:none; background:#e2e8f0;
    padding:4px 8px; border-radius:8px; cursor:pointer;
  }
  .part-fly .help{margin-top:-4px}

  /* 右下座標HUD（3D/成長視圖用） */
  .hud{
    position:absolute; right:10px; bottom:10px;
    font:12px/1.2 system-ui,Arial;
    background:rgba(15,23,42,.85); color:#e5e7eb;
    padding:6px 8px; border-radius:8px; z-index:6;
  }
  .hud .lab{opacity:.7; margin-right:4px}

  /* 平台浮動面板（只在 3D 視圖顯示） */
  .platform-overlay{
    position:absolute; right:12px; top:12px; z-index:9;
    display:block;
    background:rgba(255,255,255,.96);
    border:1px solid #cbd5e1; border-radius:10px;
    padding:10px; min-width:220px; box-shadow:0 10px 22px rgba(0,0,0,.12);
  }
  .platform-overlay .title{font-weight:700; font-size:13px; color:#0f172a; margin-bottom:6px;}
  .platform-overlay .row{gap:6px}
  .platform-overlay input{margin-bottom:0}
  .platform-overlay .small-btns{margin-top:6px}

  /* ===== 左下方形軸預覽（回到畫面固定小軸） ===== */
  #axes-canvas{
    position:absolute;
    left:16px;
    bottom:10px;
    z-index:1000;
    width:150px;
    height:150px;
    border:none;
    border-radius:0;
    background:transparent;
    pointer-events:auto;
    cursor:grab;
  }
  #axes-canvas.dragging{ cursor:grabbing; }
  #axes-overlay{
    position:absolute;
    left:16px;
    bottom:10px;
    z-index:1001;
    width:150px;
    height:150px;
    pointer-events:none;
  }

  /* 切片播放控制框（預設在切片視圖左下，可拖曳） */
  .slice-play-overlay{
    position:absolute;
    left:16px;
    bottom:16px;
    z-index:9;
    min-width:220px;
    padding:8px 10px;
    background:rgba(255,255,255,0.96);
    border:1px solid #cbd5e1;
    border-radius:10px;
    box-shadow:0 8px 20px rgba(0,0,0,.15);
    display:none;
  }
  .slice-play-header{
    font-size:13px;
    font-weight:700;
    color:#0f172a;
    margin-bottom:4px;
    cursor:grab;
  }
  .slice-play-overlay.dragging{
    cursor:grabbing;
    user-select:none;
  }
  #slice-play-speed{
    width:80px;
    margin-bottom:6px;
    font-size:12px;
    padding:4px 6px;
  }

</style>

</head>
<body>

  <div class="header"><h2>3D模型切片器</h2></div>
  <div class="main">
    <div class="panel controls">
      <div class="panel-title">1. 導入 3D 模型</div>
      <input id="file-input" type="file" accept=".stl,.obj,.3mf,.bmp" multiple />


  <div class="panel-title">2. 模型定位</div>
  <span id="select-badge" class="badge-select">未選取零件</span>
  <div class="small-btns">
    <button id="center-model">重設至原始載入（選取/全部）</button>
    <button id="reset-transform">貼地（全部）</button>
  </div>

  <div class="panel-title">2.1 精準旋轉（世界座標；僅對選取零件）</div>
  <div class="row">
    <select id="rotate-axis" disabled>
      <option value="x">X</option>
      <option value="y">Y</option>
      <option value="z" selected>Z</option>
    </select>
    <input id="rotate-deg" type="number" step="0.1" value="0" placeholder="角度（度）" disabled />
    <button id="btn-rot-rel" disabled>執行旋轉</button>
  </div>
  <div class="axis-badge" id="axis-badge"><span class="dot z"></span><span>Z</span></div>
  <div class="small-btns" style="margin-top:6px">
    <button id="btn-rot-cw"  disabled>+90°</button>
    <button id="btn-rot-ccw" disabled>-90°</button>
  </div>
  <button id="delete-selected" disabled>刪除選取零件 (Delete)</button>

  <div class="panel-title">3. 模型顏色與切片解析度</div>
  <label>模型顏色（單色模式預設色）</label>
  <input id="model-color" type="color" value="#3498db" />
  
  <div>
    <label>切片最大邊（px）<small id="pxcap-label">2048</small></label>
    <input id="slice-max-px" type="range" min="256" max="4096" step="128" value="2048" />
  </div>
  
  <div class="panel-title">4. 切片設定</div>
  <label>層厚 (mm)</label>
  <input id="layer-height" type="number" min="0.01" max="10" step="0.01" value="1" />
  <button id="slice-button" disabled>切片（選取/全部）</button>
  
  <div class="panel-title">5. 切片控制</div>
  <div class="pill">當前層：<span id="current-layer">0</span> / <span id="total-layers">0</span></div>
  <div class="layers-list" id="layers-list"></div>
  <div class="small-btns" style="margin-top:6px">
    <button id="prev-layer">上一層</button>
    <button id="next-layer">下一層</button>
  </div>
  <div class="small-btns" style="margin-top:6px">
    <button id="first-layer">第一層</button>
    <button id="last-layer">最後層</button>
  </div>

  <hr class="sep" />
  <div class="panel-title">6. 視覺設定（目前層即時生效）</div>

  <div class="form-row" style="margin-top:0">
    <label class="chk"><input id="use-part-colors" type="checkbox" /><span>使用分件顏色（多色，源自檔案）</span></label>
    <span class="muted" id="color-hint"></span>
  </div>

  <label>顏色（目前層；單色基色）</label>
  <input id="ui-color" type="color" value="#e74c3c" />

  <div class="form-row" style="margin-top:0">
    <label class="chk"><input id="toggle-scale-bar" type="checkbox" /><span>顯示比例尺（僅預覽，不含輸出）</span></label>
  </div>

  <div class="form-row" style="margin-top:0">
    <label class="chk"><input id="ui-gray2-enable" type="checkbox" /><span>啟用區域灰階（同心分層）</span></label>
  </div>
  <label>灰階分階數（含背景；2–10）<small id="ui-gray2-steps-label">5</small></label>
  <input id="ui-gray2-steps" type="range" min="2" max="10" step="1" value="5" disabled />
  <label>灰階模式</label>
  <select id="ui-gray2-mode" disabled>
    <option value="centroid-in">質心→外框（每區塊各自質心）</option>
    <option value="centroid-out">外框→質心（每區塊各自質心）</option>
    <option value="edge-in" selected>外框向內（僅外框作為起點）</option>
    <option value="edge-out">內向外框（反相；僅外框作為終點）</option>
  </select>
  
  <label>像素密度（超取樣；目前層）</label>
  <input id="ui-pixel" type="range" min="0" max="5" step="1" value="0" />
  
  <div class="small-btns" style="margin-top:6px">
    <button id="apply-to-all">將目前層設定套用至所有層</button>
  </div>

  <hr class="sep" />
  <div class="panel-title">7. 匯出（影像）</div>
  <select id="export-type">
    <option value="bmp">BMP（當前切片）</option>
    <option value="png">PNG（當前切片）</option>
    <option value="jpg" selected>JPG（當前切片）</option>
  </select>
  <label>輸出影像尺寸（px，依平台比例）</label>
  <div class="row">
    <input id="export-width" type="number" min="256" max="4096" step="128" value="2048" placeholder="寬度 (px)" />
    <input id="export-height" type="number" min="256" max="4096" step="128" placeholder="高度 (px)" />
  </div>
  <div class="hint">輸入「寬」或「高」後按 Enter / 失焦，另一邊會依平台長寬比例自動更新。</div>
  <button id="export-button">匯出目前切片</button>
  <button id="export-all-folder" disabled>存全部切層到資料夾</button>
  
  <hr class="sep" />
  <div class="panel-title">8. 模型成長視圖（3D）</div>
  <div class="row">
    <input id="growth-layer-input" type="number" min="0" value="0" />
    <input id="growth-speed" type="number" min="1" max="60" step="1" value="5" />
  </div>

  <input id="growth-slider" type="range" min="0" max="0" step="1" value="0" />
  <div class="small-btns">
    <button id="growth-animate">播放/暫停</button>
    <button id="growth-stop">停止</button>
  </div>
  <button id="growth-play-to-target">從第一層長到目標層</button>
</div>

<div class="viewer">
  <div class="tabs">
    <div class="tab active" id="model-tab">3D 模型視圖</div>
    <div class="tab" id="slice-tab">切片視圖</div>
    <div class="tab" id="growth-tab">成長視圖</div>
  </div>

  <div class="canvas-wrap" style="flex:1;position:relative;">
    <button id="box-select-toggle" class="box-toggle hidden" title="啟用/停用框選（Esc 取消）">框選</button>
    <div id="marquee" class="marquee"></div>

    <!-- 平台浮動面板（只在 3D 視圖顯示） -->
    <div id="platform-overlay" class="platform-overlay">
      <div class="title">平台設定（mm）</div>
      <div class="row">
        <input id="plate-width"  type="number" min="1" step="1" value="200" placeholder="平台寬 X (mm)" />
        <input id="plate-height" type="number" min="1" step="1" value="200" placeholder="平台高 Y (mm)" />
      </div>
      <div class="small-btns"><button id="apply-platform">套用平台尺寸</button></div>
      <div class="help" style="margin-top:4px">切片固定以平台視窗輸出；3D 與成長視圖同步更新。</div>
    </div>

    <!-- 左下角小軸（畫面固定） -->
    <canvas id="axes-canvas"></canvas>
    <canvas id="axes-overlay"></canvas>

    <!-- 切片播放控制（只在切片視圖顯示，可拖曳） -->
    <div id="slice-play-overlay" class="slice-play-overlay">
      <div id="slice-play-header" class="slice-play-header">切片播放</div>
      <input id="slice-play-speed" type="number" min="1" max="60" step="1" value="5" title="層/秒 (播放速度)" />
      <input id="slice-play-slider" type="range" min="1" max="1" step="1" value="1" />
      <div class="small-btns" style="margin-top:6px;">
        <button id="slice-play-animate">播放 / 暫停</button>
        <button id="slice-play-stop">停止</button>
      </div>
    </div>

    <canvas id="model-canvas"></canvas>
    <canvas id="slice-canvas"></canvas>
    <input id="layer-slider" type="range" min="1" max="1" value="1" step="1" />

    <!-- 右下座標HUD（3D/成長視圖用） -->
    <div id="coords-hud" class="hud" style="display:none;">
      <span class="lab">X</span><span id="hud-x">0.00</span>&nbsp;
      <span class="lab">Y</span><span id="hud-y">0.00</span>&nbsp;
      <span class="lab">Z</span><span id="hud-z">0.00</span>
    </div>

    <!-- 切片視圖：零件視覺設定浮窗 -->
    <div id="part-fly" class="part-fly">
      <button class="close" id="part-fly-close">關閉</button>
      <div class="title" id="part-fly-title">零件視覺設定</div>
      <label>顏色</label>
      <input id="pf-color" type="color" value="#e74c3c" />
      <div class="form-row" style="margin-top:0">
        <label class="chk"><input id="pf-gray-enable" type="checkbox" /><span>啟用區域灰階</span></label>
      </div>
      <label>灰階分階數（2–10）<small id="pf-steps-lab">5</small></label>
      <input id="pf-steps" type="range" min="2" max="10" step="1" value="5" disabled />
      <label>灰階模式</label>
      <select id="pf-mode" disabled>
        <option value="centroid-in">質心→外框</option>
        <option value="centroid-out">外框→質心</option>
        <option value="edge-in" selected>外框向內</option>
        <option value="edge-out">內向外框</option>
      </select>
      <label>像素密度（超取樣）</label>
      <input id="pf-pixel" type="range" min="0" max="5" step="1" value="0" />
      <div class="help">此設定只影響：<b>當前零件＋當前層</b>。<br>提示：不論是否勾選「多色」，皆可自訂零件視覺；後改者優先。</div>
    </div>
  </div>
</div>
```

  </div>

  <!-- 進度條（共用） -->

  <div id="progress" class="progress">
    <div class="title" id="progress-title">處理中…</div>
    <div class="bar"><span id="progress-bar"></span></div>
    <div class="percent" id="progress-percent">0%</div>
  </div>

<script>
/* =============================== 全域狀態 =============================== */
let scene, camera, renderer, controls;
let axesHelper, gridHelper, platformBorder;

/* 平台左下角 3D 方塊軸（改用畫面固定小軸，不再顯示） */
let platformAxesGroup = null;

/* 迷你三軸（左下角小場景，畫面固定） */
let miniAxesRenderer, miniAxesScene, miniAxesCamera;
let miniAxesCanvas, axesOverlayCanvas;
let miniAxesDragging = false;
let miniAxesLast = {x:0,y:0};

/* 平台（XY 平面；Z 為上） */
let platform = { width: 200, height: 200 }; // mm（X 寬、Y 高）  

/* 多零件 */
let model = null; // 作為 rootGroup
let parts = [];   // {id, root, name, helper, selected, original:{pos,quat,scale}}
let partIdSeq = 1;

/* 選取 / 拖曳 */
let raycaster = new THREE.Raycaster();
let mouseNdc = new THREE.Vector2();
let isDraggingPart = false;
/* 拖曳平面：z=0 */
let dragPlane = new THREE.Plane(new THREE.Vector3(0,0,1), 0); // z=0
let dragOffset = new THREE.Vector3();
let dragStartHit = new THREE.Vector3();

/* 框選模式切換 */
let activeTab = 'model';
let boxSelectEnabled = false;

/* 切片資料（切 Z、投影 XY） */
let baseSlices = [];       // 每層：{frameW,frameH,mask,x,y,w,h,parts[],analysis?,partAnalyses?, zMid,zLow,zHigh}
let layerSettings = [];    // 每層設定（全域層）
let currentSliceIndex = 0;
let sliceThickness = 1;
let pxPerUnitGlobal = 2;
let pxPerUnitScaleBar = 1;

/* 切片邊界（給成長視圖用） */
let sliceBounds = { xMin:0, xMax:0, yMin:0, yMax:0, zMin:0 };

/* 成長視圖 */
let growthGroup = null;
let growthBuilt = false;
let growthPlaying = false;
let growthRAF = 0;
let growthShownLayers = 0;

const GROWTH_MAX_TEX = 1024;
const GROWTH_RESIDENT_TARGET_MB = 256;
let growthLoaded = new Map();

/* 分件視覺（僅資料） */
const partVisuals = new Map(); // pid -> { color:string, pixelLevel:number }

/* 切片內「零件-層」獨立設定（含版本） */
const partSliceSettings = new Map(); // key `${layer}:${pid}` -> {color, gray2Enabled, gray2Steps, gray2Mode, pixelLevel, _ver}

/* 版本機制：誰後改誰優先 */
let verSeq = 0;

/* UI 元件 */
const fileInput = document.getElementById('file-input');
const sliceCanvas = document.getElementById('slice-canvas');
const sliceCtx = sliceCanvas.getContext('2d', { willReadFrequently:true });
const layerSlider = document.getElementById('layer-slider');
const uiColor = document.getElementById('ui-color');
const uiPixel = document.getElementById('ui-pixel');
const modelColorInput = document.getElementById('model-color');
const pxCapRange = document.getElementById('slice-max-px');
const pxCapLabel = document.getElementById('pxcap-label');
const toggleScaleBar = document.getElementById('toggle-scale-bar');
const usePartColorsChk = document.getElementById('use-part-colors'); // ★ 只決定基色來源
const colorHint = document.getElementById('color-hint');
const growthSlider = document.getElementById('growth-slider');
const growthInput  = document.getElementById('growth-layer-input');
const growthAnimateBtn = document.getElementById('growth-animate');
const growthStopBtn    = document.getElementById('growth-stop');
const growthSpeedInput = document.getElementById('growth-speed');
const layerHeightInput = document.getElementById('layer-height');
const rotateAxisSel  = document.getElementById('rotate-axis');
const rotateDegInput = document.getElementById('rotate-deg');
const selectBadgeEl = document.getElementById('select-badge');
const boxToggleBtn = document.getElementById('box-select-toggle');
const plateWInput = document.getElementById('plate-width');
const plateHInput = document.getElementById('plate-height');
const exportWidthInput = document.getElementById('export-width');
const exportHeightInput = document.getElementById('export-height');
/* 老變數避免殘留引用出錯（實際不用） */
const exportSizeInput = null;

/* 切片視圖：零件小窗 */
const partFly = document.getElementById('part-fly');
const partFlyTitle = document.getElementById('part-fly-title');
const partFlyClose = document.getElementById('part-fly-close');
const pfColor = document.getElementById('pf-color');
const pfGrayEnable = document.getElementById('pf-gray-enable');
const pfSteps = document.getElementById('pf-steps');
const pfStepsLab = document.getElementById('pf-steps-lab');
const pfMode = document.getElementById('pf-mode');
const pfPixel = document.getElementById('pf-pixel');

/* 座標HUD（射到 z=0） */
const hud = document.getElementById('coords-hud');
const hudX = document.getElementById('hud-x');
const hudY = document.getElementById('hud-y');
const hudZ = document.getElementById('hud-z');

/* 平台浮動面板與小軸畫布 */
const platformOverlay = document.getElementById('platform-overlay');
miniAxesCanvas = document.getElementById('axes-canvas');
axesOverlayCanvas = document.getElementById('axes-overlay');

const uiGray2Enable = document.getElementById('ui-gray2-enable');
const uiGray2Steps  = document.getElementById('ui-gray2-steps');
const uiGray2StepsLabel = document.getElementById('ui-gray2-steps-label');
const uiGray2Mode   = document.getElementById('ui-gray2-mode');

/* 切片播放控制（切片視圖用） */
const slicePlayOverlay = document.getElementById('slice-play-overlay');
const slicePlayHeader = document.getElementById('slice-play-header');
const slicePlaySlider = document.getElementById('slice-play-slider');
const slicePlayAnimateBtn = document.getElementById('slice-play-animate');
const slicePlayStopBtn = document.getElementById('slice-play-stop');
const slicePlaySpeedInput = document.getElementById('slice-play-speed');
let slicePlaying = false;
let slicePlayRAF = 0;
let slicePlayPos = 0;
let slicePlayDragging = false;
let slicePlayDragOffset = {x:0,y:0};
let slicePlayPointerId = null;

const DEFAULT_PX_PER_UNIT = 2.0;
const MIN_CANVAS = 128;
const MAX_CANVAS = 4096;

let frameWGlobal = 0, frameHGlobal = 0;
let modelBaseName = 'slices';
let pxCapDebounce = null;

/* 比例尺狀態 */
let scaleBarEnabled = false;

/* 顏色 */
let defaultSliceColor = '#e74c3c';
const textureAvgCache = new WeakMap();

/* 進度條 */
const progEl = document.getElementById('progress');
const progTitle = document.getElementById('progress-title');
const progBar = document.getElementById('progress-bar');
const progPct = document.getElementById('progress-percent');
function showProgress(title, p){
  progTitle.textContent = title || '處理中…';
  const percent = Math.max(0, Math.min(1, p||0));
  progBar.style.width = (percent*100).toFixed(1)+'%';
  progPct.textContent = (percent*100).toFixed(0)+'%';
  progEl.style.display = 'block';
}
function hideProgress(){ progEl.style.display = 'none'; }
const nextFrame = ()=> new Promise(r=> requestAnimationFrame(()=> r()));

/* 渲染節流 */
let isInteracting = false;
let sliceRenderRAF = 0;
function scheduleRenderSlice(idx, fast=false){
  if(sliceRenderRAF) cancelAnimationFrame(sliceRenderRAF);
  sliceRenderRAF = requestAnimationFrame(()=> renderSlice(idx, fast));
}

/* 讓切片滑桿避開比例尺 */
function updateLayerSliderPosition(){
  layerSlider.style.bottom = scaleBarEnabled ? '54px' : '10px';
}

/* =============================== 初始化 Three.js =============================== */
function initThree() {
  const canvas = document.getElementById('model-canvas');
  const pr = Math.min(1.5, window.devicePixelRatio || 1);
  renderer = new THREE.WebGLRenderer({ canvas, antialias:true, preserveDrawingBuffer:true, alpha:true });
  renderer.setPixelRatio(pr);
  renderer.setSize(canvas.clientWidth, canvas.clientHeight);

  scene = new THREE.Scene();
  scene.background = new THREE.Color(0xf0f0f0);

  camera = new THREE.PerspectiveCamera(60, canvas.clientWidth/canvas.clientHeight, 0.1, 5000);
  /* Z 向上 */
  camera.up.set(0,0,1);
  camera.position.set(200,200,200);

  controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.rotateSpeed = 0.6;

  // 自訂矩形平台格線（XY 平面 z=0）
  updatePlatformVisual();

  scene.add(new THREE.AmbientLight(0xffffff, 0.6));
  const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
  dirLight.position.set(1,1,1);
  scene.add(dirLight);

  axesHelper = new THREE.AxesHelper(150);
  scene.add(axesHelper);

  // root group for parts
  model = new THREE.Group();
  scene.add(model);

  // 成長視圖群組
  growthGroup = new THREE.Group();
  growthGroup.visible = false;
  scene.add(growthGroup);

  // 事件
  window.addEventListener('resize', onWindowResize);
  window.addEventListener('keydown', onKeyDown);

  // 點選 / 拖曳 / 框選
  setupPointerInteractions(renderer.domElement);

  // 框選模式切換鍵
  boxToggleBtn.addEventListener('click', ()=>{
    boxSelectEnabled = !boxSelectEnabled;
    updateBoxToggleUI();
  });

  // 軸徽章顯示
  rotateAxisSel.addEventListener('change', updateAxisBadge);

  // 3D/成長座標 HUD（射到 z=0）
  renderer.domElement.addEventListener('pointermove', onPointerMoveHud);
  renderer.domElement.addEventListener('pointerleave', ()=> hud.style.display='none');

  // 左下角小軸初始化（畫面固定）
  initMiniAxes(pr);

  // 預設：3D 視圖顯示平台浮窗與小軸
  platformOverlay.style.display = 'block';
  miniAxesCanvas.style.display = 'block';
  axesOverlayCanvas.style.display = 'block';

  updateBoxToggleUI();
  animate();
}

/* ==== 平台格線＋邊框 ==== */
function createRectPlatformGrid(width, height){
  const hw = width  / 2;
  const hh = height / 2;

  // 目標大約 20×20 格，避免太密或太疏
  const targetDiv = 20;
  const divX = Math.max(1, Math.round(width  / (width  / targetDiv)));
  const divY = Math.max(1, Math.round(height / (height / targetDiv)));
  const stepX = width  / divX;
  const stepY = height / divY;

  const positions = [];

  // 垂直線（平行 Y 軸）
  for(let i=0;i<=divX;i++){
    const x = -hw + i*stepX;
    positions.push(
      x, -hh, 0,
      x,  hh, 0
    );
  }

  // 水平線（平行 X 軸）
  for(let j=0;j<=divY;j++){
    const y = -hh + j*stepY;
    positions.push(
      -hw, y, 0,
       hw, y, 0
    );
  }

  const geom = new THREE.BufferGeometry();
  geom.setAttribute('position', new THREE.Float32BufferAttribute(positions,3));
  const mat = new THREE.LineBasicMaterial({color:0xcccccc});
  return new THREE.LineSegments(geom, mat);
}

/* 原本平台左下角 3D 方塊軸改為畫面固定小軸，此處僅保留函式 */
function createPlatformAxes(){
  if(platformAxesGroup){
    scene.remove(platformAxesGroup);
    platformAxesGroup = null;
  }
  // 不再在 3D 世界中顯示 3D 方塊軸，改用左下角畫面固定小軸
  return;
}

function updatePlatformVisual(){
  if(gridHelper){
    scene.remove(gridHelper);
    gridHelper.geometry.dispose();
    gridHelper.material.dispose();
  }
  // 矩形平台格線，完全在平台邊框內
  gridHelper = createRectPlatformGrid(platform.width, platform.height);
  scene.add(gridHelper);

  if(platformBorder){
    scene.remove(platformBorder);
    platformBorder.geometry.dispose();
    platformBorder.material.dispose();
  }
  const hw = platform.width/2, hh = platform.height/2;
  // 平台邊框：XY 平面 z=0
  const geom = new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(-hw,-hh,0), new THREE.Vector3(hw,-hh,0),
    new THREE.Vector3(hw,-hh,0), new THREE.Vector3(hw, hh,0),
    new THREE.Vector3(hw, hh,0), new THREE.Vector3(-hw, hh,0),
    new THREE.Vector3(-hw, hh,0), new THREE.Vector3(-hw,-hh,0),
  ]);
  platformBorder = new THREE.LineSegments(geom, new THREE.LineBasicMaterial({color:0x2563eb}));
  scene.add(platformBorder);

  // 不再建立 3D 方塊軸，改由畫面固定小軸提示方向
  // createPlatformAxes();
}

/* 左下角 2D 小軸 (canvas 小場景，畫面固定) */
function initMiniAxes(pr){
  miniAxesRenderer = new THREE.WebGLRenderer({canvas: miniAxesCanvas, antialias:true, alpha:true});
  miniAxesRenderer.setPixelRatio(pr);
  miniAxesRenderer.setSize(miniAxesCanvas.clientWidth, miniAxesCanvas.clientHeight, false);

  miniAxesScene = new THREE.Scene();
  miniAxesScene.background = null;

  miniAxesCamera = new THREE.PerspectiveCamera(45, 1, 0.1, 20);
  miniAxesCamera.up.set(0,0,1);
  miniAxesCamera.position.set(0,0,4);
  miniAxesCamera.lookAt(0,0,0);

  // 一顆小立方體
  const boxGeo = new THREE.BoxGeometry(1.4,1.4,1.4);
  const materials = [
    new THREE.MeshBasicMaterial({color:0xf97373}),
    new THREE.MeshBasicMaterial({color:0x9ca3af}),
    new THREE.MeshBasicMaterial({color:0x6ee7b7}),
    new THREE.MeshBasicMaterial({color:0x9ca3af}),
    new THREE.MeshBasicMaterial({color:0xbfdbfe}),
    new THREE.MeshBasicMaterial({color:0x9ca3af}),
  ];
  const cube = new THREE.Mesh(boxGeo, materials);
  miniAxesScene.add(cube);
  const edgeGeo = new THREE.EdgesGeometry(boxGeo);
  const edgeLines = new THREE.LineSegments(edgeGeo, new THREE.LineBasicMaterial({color:0x374151}));
  miniAxesScene.add(edgeLines);

  const addArrow = (dir, colorHex, label) => {
    const length = 1.1, headLength=0.26, headWidth=0.14;
    const ah = new THREE.ArrowHelper(dir, new THREE.Vector3(0,0,0), length, colorHex, headLength, headWidth);
    miniAxesScene.add(ah);
    const sprite = makeTextSprite(label, colorHex);
    sprite.position.copy(dir.clone().multiplyScalar(length+0.2));
    miniAxesScene.add(sprite);
  };
  addArrow(new THREE.Vector3(1,0,0), 0xff5555, 'X');
  addArrow(new THREE.Vector3(0,1,0), 0x22c55e, 'Y');
  addArrow(new THREE.Vector3(0,0,1), 0x4e79ff, 'Z');

  miniAxesCanvas.addEventListener('pointerdown', (e)=>{
    miniAxesDragging = true;
    miniAxesCanvas.classList.add('dragging');
    miniAxesCanvas.setPointerCapture(e.pointerId);
    miniAxesLast.x = e.clientX; miniAxesLast.y = e.clientY;
    e.preventDefault();
  });
  miniAxesCanvas.addEventListener('pointermove', (e)=>{
    if(!miniAxesDragging) return;
    const dx = e.clientX - miniAxesLast.x;
    const dy = e.clientY - miniAxesLast.y;
    miniAxesLast.x = e.clientX; miniAxesLast.y = e.clientY;
    const w = miniAxesCanvas.clientWidth, h = miniAxesCanvas.clientHeight;
    const rotSpeed = Math.PI * 2;
    controls.rotateLeft( (dx / w) * rotSpeed );
    controls.rotateUp(   (dy / h) * rotSpeed );
    controls.update();
    e.preventDefault();
  });
  function endMiniAxesDrag(e){
    if(!miniAxesDragging) return;
    miniAxesDragging = false;
    miniAxesCanvas.classList.remove('dragging');
    if(e && e.pointerId) try{ miniAxesCanvas.releasePointerCapture(e.pointerId); }catch(_){}
  }
  miniAxesCanvas.addEventListener('pointerup', endMiniAxesDrag);
  miniAxesCanvas.addEventListener('pointerleave', endMiniAxesDrag);

  updateAxesOverlaySize(pr);
  renderAxesOverlay2D();
}

function makeTextSprite(text, color){
  const canvas = document.createElement('canvas');
  const s = 128;
  canvas.width = canvas.height = s;
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0,0,s,s);
  ctx.fillStyle = `#${new THREE.Color(color).getHexString()}`;
  ctx.font = 'bold 80px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(text, s/2, s/2);
  const tex = new THREE.CanvasTexture(canvas);
  const mat = new THREE.SpriteMaterial({map:tex, transparent:true});
  const sp = new THREE.Sprite(mat);
  sp.scale.set(0.35,0.35,0.35);
  return sp;
}

function updateAxesOverlaySize(pr = Math.min(1.5, window.devicePixelRatio || 1)){
  const cw = axesOverlayCanvas.clientWidth;
  const ch = axesOverlayCanvas.clientHeight;
  axesOverlayCanvas.width  = Math.max(1, Math.floor(cw * pr));
  axesOverlayCanvas.height = Math.max(1, Math.floor(ch * pr));
}
function renderAxesOverlay2D(){
  if(!axesOverlayCanvas) return;
  const ctx = axesOverlayCanvas.getContext('2d');
  const w = axesOverlayCanvas.width, h = axesOverlayCanvas.height;
  ctx.save();
  ctx.clearRect(0,0,w,h);
  ctx.restore();
}
function renderMiniAxes(){
  if(!miniAxesRenderer || !miniAxesScene || !miniAxesCamera) return;
  miniAxesCamera.quaternion.copy(camera.quaternion);
  miniAxesRenderer.render(miniAxesScene, miniAxesCamera);
  renderAxesOverlay2D();
}

function updateAxisBadge(){
  const badge = document.getElementById('axis-badge');
  const v = rotateAxisSel.value;
  badge.innerHTML = '';
  const dot = document.createElement('span'); dot.className = `dot ${v}`;
  const t = document.createElement('span'); t.textContent = v.toUpperCase();
  badge.appendChild(dot); badge.appendChild(t);
}

function updateBoxToggleUI(){
  const wrap = document.querySelector('.canvas-wrap');
  const inModel = (activeTab==='model');
  boxToggleBtn.classList.toggle('hidden', !inModel);
  boxToggleBtn.classList.toggle('active', inModel && boxSelectEnabled);
  boxToggleBtn.textContent = (inModel && boxSelectEnabled) ? '框選中（Esc 取消）' : '框選';
  wrap.classList.toggle('select-mode', inModel && boxSelectEnabled);
}

function animate(){
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
  renderMiniAxes();
}

function onWindowResize(){
  const canvas = renderer.domElement;
  renderer.setSize(canvas.clientWidth, canvas.clientHeight);
  camera.aspect = canvas.clientWidth / canvas.clientHeight;
  camera.updateProjectionMatrix();

  if(miniAxesRenderer && miniAxesCanvas){
    miniAxesRenderer.setSize(miniAxesCanvas.clientWidth, miniAxesCanvas.clientHeight, false);
  }
  updateAxesOverlaySize();
  renderAxesOverlay2D();

  layoutSliceCanvas();
}

/* =============================== 多零件：工具 =============================== */
function addPart(root, name){
  root.userData.partId = partIdSeq++;
  const original = {
    pos: root.position.clone(),
    quat: root.quaternion.clone(),
    scale: root.scale.clone(),
  };

  const helper = new THREE.BoxHelper(root, 0x10b981);
  helper.visible = false;
  scene.add(helper);

  const rec = { id: root.userData.partId, root, name, helper, selected:false, original };
  parts.push(rec);
  model.add(root);
  updatePartsHelpers();
  refreshSelectionBadge();
  finishLoad(true);
}

/* 貼到 z=0（XY 平面） */
function groundPartToPlane(rec){
  rec.root.updateMatrixWorld(true);
  const box = new THREE.Box3().setFromObject(rec.root);
  const minZ = box.min.z;
  rec.root.position.z -= minZ;
  rec.root.updateMatrixWorld(true);
  rec.helper.update();
}
function groundAll(){
  if(parts.length===0) return;
  parts.forEach(p=> groundPartToPlane(p));
  updatePartsHelpers();
  controls.update();
}

function resetToOriginal(selectedOnly){
  const list = selectedOnly ? getSelectedParts() : parts;
  list.forEach(p=>{
    p.root.position.copy(p.original.pos);
    p.root.quaternion.copy(p.original.quat);
    p.root.scale.copy(p.original.scale);
    p.root.updateMatrixWorld(true);
  });
  updatePartsHelpers();
  controls.update();
}

function getSelectedParts(){ return parts.filter(p=>p.selected); }
function getSelectedMeshes(){
  const arr = [];
  getSelectedParts().forEach(p=>{
    p.root.updateWorldMatrix(true,true);
    p.root.traverse(o=>{ if(o.isMesh && o.geometry && o.geometry.attributes?.position){ arr.push(o); } });
  });
  return arr;
}
function getAllMeshes(){
  const arr = [];
  parts.forEach(p=>{
    p.root.updateWorldMatrix(true,true);
    p.root.traverse(o=>{ if(o.isMesh && o.geometry && o.geometry.attributes?.position){ arr.push(o); } });
  });
  return arr;
}

function selectNone(){
  parts.forEach(p=>{ p.selected=false; p.helper.visible=false; });
  updateUiBySelection();
}
function setSelected(partsArr, additive=false){
  if(!additive) selectNone();
  partsArr.forEach(p=>{ p.selected=true; p.helper.visible=true; });
  updatePartsHelpers();
  updateUiBySelection();
}
function toggleSelectOne(p){
  p.selected = !p.selected;
  p.helper.visible = p.selected;
  updatePartsHelpers();
  updateUiBySelection();
}
function updatePartsHelpers(){
  parts.forEach(p=>{ p.helper.update(); p.helper.visible = (activeTab==='model') ? p.selected : false; });
  refreshSelectionBadge();
}

function refreshSelectionBadge(){
  const n = getSelectedParts().length;
  selectBadgeEl.textContent = n ? `已選取 ${n} 件` : '未選取零件';
}

/* =============================== UI：定位/旋轉 =============================== */
function axisUnit(axis){
  return axis==='x' ? new THREE.Vector3(1,0,0) :
         axis==='y' ? new THREE.Vector3(0,1,0) :
                      new THREE.Vector3(0,0,1);
}
function applyRelativeWorldRotation(axis, deg){
  const sel = getSelectedParts();
  if(sel.length===0) return;

  const rad = THREE.MathUtils.degToRad(deg);
  const v = axisUnit(axis);

  sel.forEach(p=>{
    p.root.rotateOnWorldAxis(v, rad);

    // ★ 旋轉後自動貼地：把最低點對齊 z=0
    groundPartToPlane(p);
  });

  controls.update();
  updatePartsHelpers();
}


document.getElementById('btn-rot-rel').addEventListener('click', ()=>{
  applyRelativeWorldRotation(rotateAxisSel.value, parseFloat(rotateDegInput.value||'0')||0);
});
document.getElementById('btn-rot-cw').addEventListener('click', ()=> applyRelativeWorldRotation(rotateAxisSel.value, 90));
document.getElementById('btn-rot-ccw').addEventListener('click', ()=> applyRelativeWorldRotation(rotateAxisSel.value, -90));

function updateUiBySelection(){
  const any = getSelectedParts().length>0;
  ['rotate-axis','rotate-deg','btn-rot-rel','btn-rot-cw','btn-rot-ccw','delete-selected'].forEach(id=>{
    const el = document.getElementById(id);
    if(el) el.disabled = !any;
  });
  document.getElementById('slice-button').disabled = !(parts.length>0);
}

/* =============================== 檔案載入（多件） =============================== */
function setLoading(msg=true){
  const btn = document.getElementById('slice-button');
  if (msg){ btn.textContent = '載入中…'; btn.disabled = true; }
  else { btn.textContent = '切片（選取/全部）'; btn.disabled = !(parts.length>0); }
}
function finishLoad(ok){
  const btn = document.getElementById('slice-button');
  btn.textContent = '切片（選取/全部）';
  btn.disabled = !ok || parts.length===0;
}

fileInput.addEventListener('change', async (e)=>{
  const files = Array.from(e.target.files||[]);
  if(files.length===0) return;
  setLoading(true);
  for(const f of files){ await loadOneFileAsPart(f); }
  setLoading(false);
});

async function loadOneFileAsPart(file){
  const ext = file.name.split('.').pop().toLowerCase();
  modelBaseName = sanitizeName(file?.name?.replace(/\.[^.]+$/,'') || modelBaseName);

  const uiColorHex = modelColorInput.value || '#3498db';

  try{
    if(ext === 'stl'){
      const buf = await file.arrayBuffer();
      const loader = new THREE.STLLoader();
      const geom = loader.parse(buf);
      const mat = new THREE.MeshPhongMaterial({color: uiColorHex});
      const mesh = new THREE.Mesh(geom, mat);
      addPart(mesh, file.name);
      groundPartToPlane(parts[parts.length-1]);
    }else if(ext === 'obj'){
      const txt = await file.text();
      const loader = new THREE.OBJLoader();
      const group = loader.parse(txt);
      group.traverse(c=>{ if(c.isMesh){ c.material = new THREE.MeshPhongMaterial({color: uiColorHex}); } });
      addPart(group, file.name);
      groundPartToPlane(parts[parts.length-1]);
    }else if(ext === '3mf'){
      const buf = await file.arrayBuffer();
      const loader = new THREE.ThreeMFLoader();
      const group = loader.parse(buf);
      if (!group || !group.children || group.children.length === 0) throw new Error('3MF 無有效 mesh');
      group.traverse(o=>{
        if(o.isMesh){
          if(!o.material) o.material = new THREE.MeshPhongMaterial({ color: uiColorHex });
          if(o.geometry && !o.geometry.attributes.normal) o.geometry.computeVertexNormals();
        }
      });
      addPart(group, file.name);
      groundPartToPlane(parts[parts.length-1]);
    }else if(ext === 'bmp'){
      const url = URL.createObjectURL(file);
      const tex = await new Promise(res=> new THREE.TextureLoader().load(url, t=>res(t)));
      const plane = new THREE.Mesh(
        new THREE.PlaneGeometry(200,200),
        new THREE.MeshBasicMaterial({map: tex, side: THREE.DoubleSide})
      );
      addPart(plane, file.name);
      groundPartToPlane(parts[parts.length-1]);
    }else{
      alert('不支援的格式：' + ext);
      return;
    }
  }catch(err){
    console.error('載入失敗：', err);
    alert('載入失敗：' + (err?.message || err));
  }
}

/* =============================== 顏色（僅選取/全部） =============================== */
function setColorForTargets(hex){
  const targets = getSelectedParts().length ? getSelectedParts() : parts;
  targets.forEach(p=>{
    p.root.traverse(o=>{
      if(o.isMesh){
        if(Array.isArray(o.material)){
          o.material.forEach(m=>{ if(m?.color) m.color.set(hex); if(m) m.needsUpdate = true; });
        }else if(o.material?.color){
          o.material.color.set(hex);
          o.material.needsUpdate = true;
        }
      }
    });
    partVisuals.set(
      p.id,
      { ...(partVisuals.get(p.id)||{}), color: hex, pixelLevel:(partVisuals.get(p.id)?.pixelLevel||0) }
    );
  });
  if(baseSlices.length) scheduleRenderSlice(currentSliceIndex, true);
}
modelColorInput.addEventListener('input', ()=>{
  const hex = modelColorInput.value;
  setColorForTargets(hex);
  defaultSliceColor = hex;
  if(layerSettings.length){
    scheduleRenderSlice(currentSliceIndex);
  }
});

/* =============================== 解析度滑桿 =============================== */
function getPxCap(){ const v = parseInt(pxCapRange.value,10); return Math.max(256, Math.min(4096, isNaN(v)?2048:v)); }
pxCapLabel.textContent = String(getPxCap());
pxCapRange.addEventListener('input', ()=>{
  pxCapLabel.textContent = String(getPxCap());
  if(parts.length===0 || baseSlices.length===0) return;
  if(pxCapDebounce) cancelAnimationFrame(pxCapDebounce);
  pxCapDebounce = requestAnimationFrame(async ()=>{
    const savedSettings = layerSettings.map(s=> ({...s}));
    const savedIndex = currentSliceIndex;
    await generateSlices();
    for(let i=0;i<Math.min(savedSettings.length, layerSettings.length); i++){
      const v = layerSettings[i]?._ver||0;
      layerSettings[i] = {...savedSettings[i], _ver: v};
    }
    buildLayerList(layerSettings.length);
    scheduleRenderSlice(Math.min(savedIndex, layerSettings.length-1));
  });
});

/* =============================== 複製 / 貼上 =============================== */
let clipboardPartIds = [];
function copySelectedParts(){
  const sel = getSelectedParts();
  if(!sel.length) return;
  clipboardPartIds = sel.map(p=>p.id);
}
function pasteClipboardParts(){
  if(!clipboardPartIds.length) return;
  const OFFSET = 10;
  clipboardPartIds.forEach(pid=>{
    const src = parts.find(p=>p.id===pid);
    if(!src) return;
    const clone = src.root.clone(true);
    clone.traverse(o=>{
      if(o.isMesh){
        if(Array.isArray(o.material)){ o.material = o.material.map(m=>m?.clone?m.clone():m); }
        else if(o.material){ o.material = o.material.clone(); }
      }
    });
    clone.position.x += OFFSET;
    clone.position.y += OFFSET;
    addPart(clone, src.name + '（複製）');
    groundPartToPlane(parts[parts.length-1]);
  });
}
function onKeyDown(e){
  if(e.key==='Delete'){
    if(getSelectedParts().length){
      e.preventDefault();
      deleteSelected();
      return;
    }
  }
  if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='c'){ e.preventDefault(); copySelectedParts(); return; }
  if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='v'){ e.preventDefault(); pasteClipboardParts(); return; }

  if(e.key==='Escape'){
    if(boxSelectEnabled){ boxSelectEnabled=false; updateBoxToggleUI(); }
    resetInteractiveUi();
  }

  if(baseSlices.length && document.getElementById('slice-tab').classList.contains('active')){
    if(e.key==='ArrowLeft'){ scheduleRenderSlice(Math.max(0,currentSliceIndex-1), true); e.preventDefault(); }
    if(e.key==='ArrowRight'){ scheduleRenderSlice(Math.min(baseSlices.length-1,currentSliceIndex+1), true); e.preventDefault(); }
    if(e.key==='Home'){ scheduleRenderSlice(0); e.preventDefault(); }
    if(e.key==='End'){ scheduleRenderSlice(baseSlices.length-1); e.preventDefault(); }
  }
}

/* 刪除選取零件 */
function deleteSelected(){
  const sel=getSelectedParts(); if(sel.length===0) return;
  const ids=sel.map(s=>s.id);
  sel.forEach(p=>{
    scene.remove(p.helper);
    model.remove(p.root);
  });
  parts = parts.filter(p=>!p.selected);
  for(const k of Array.from(partSliceSettings.keys())){
    const [layerStr,pidStr]=k.split(':'); if(ids.includes(Number(pidStr))) partSliceSettings.delete(k);
  }
  updatePartsHelpers(); updateUiBySelection();
}

/* =============================== 滑鼠互動（點選 / 框選 / 平移拖曳） =============================== */
function setupPointerInteractions(dom){
  const marquee = document.getElementById('marquee');
  const wrap = dom.parentElement;
  let pointerDown = false;
  let downPos = {x:0, y:0};
  let moved = false;
  let marqueeOn = false;
  let marqueeRect = {x:0,y:0,w:0,h:0};
  let lastIntersectPart = null;
  const DRAG_START_DIST = 5;

  function getMouseNdc(ev){
    const rect = dom.getBoundingClientRect();
    mouseNdc.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
    mouseNdc.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
  }
  function hitTest(ev){
    getMouseNdc(ev);
    raycaster.setFromCamera(mouseNdc, camera);
    const objs = [];
    parts.forEach(p=>{
      p.root.traverse(o=>{ if(o.isMesh) objs.push(o); });
    });
    const hits = raycaster.intersectObjects(objs, true);
    if(hits.length){
      const mesh = hits[0].object;
      let root = mesh;
      while(root && !root.userData?.partId) root = root.parent;
      if(root){
        const pid = root.userData.partId;
        return parts.find(p=>p.id===pid) || null;
      }
    }
    return null;
  }

  dom.addEventListener('pointerdown', (ev)=>{
    if(ev.button!==0) return;
    if(activeTab!=='model') return;

    pointerDown = true; moved=false;

    const wrect = wrap.getBoundingClientRect();
    downPos = {x: ev.clientX - wrect.left, y: ev.clientY - wrect.top};

    lastIntersectPart = hitTest(ev);

    if(lastIntersectPart && lastIntersectPart.selected){
      controls.enabled = false;
      isDraggingPart = true;
      raycaster.setFromCamera(mouseNdc, camera);
      const hit = new THREE.Vector3();
      raycaster.ray.intersectPlane(dragPlane, hit);
      dragStartHit.copy(hit);
      dragOffset.copy(lastIntersectPart.root.position).sub(hit);
      return;
    }
    marqueeOn = false;
  });

  dom.addEventListener('pointermove', (ev)=>{
    if(!pointerDown) return;
    if(activeTab!=='model') return;

    moved = true;
    getMouseNdc(ev);

    if(isDraggingPart && lastIntersectPart){
      raycaster.setFromCamera(mouseNdc, camera);
      const hit = new THREE.Vector3();
      if(raycaster.ray.intersectPlane(dragPlane, hit)){
        const target = hit.clone().add(dragOffset);
        lastIntersectPart.root.position.x = target.x;
        lastIntersectPart.root.position.y = target.y;
        updatePartsHelpers();
      }
      return;
    }

    if(!boxSelectEnabled) return;
    const wrect = wrap.getBoundingClientRect();
    const curr = {x: ev.clientX - wrect.left, y: ev.clientY - wrect.top};
    const dx = curr.x - downPos.x, dy = curr.y - downPos.y;

    if(!marqueeOn && Math.hypot(dx,dy) >= DRAG_START_DIST){
      marqueeOn = true;
      controls.enabled = false;
    }

    if(marqueeOn){
      const x = Math.min(downPos.x, curr.x), y = Math.min(downPos.y, curr.y);
      const w = Math.abs(curr.x - downPos.x), h = Math.abs(curr.y - downPos.y);
      marqueeRect = {x, y, w, h};
      marquee.style.left = `${x}px`;
      marquee.style.top  = `${y}px`;
      marquee.style.width = `${w}px`;
      marquee.style.height= `${h}px`;
      marquee.style.display = 'block';
    }
  });

  dom.addEventListener('pointerup', (ev)=>{
    if(!pointerDown) return;
    pointerDown = false;

    if(isDraggingPart){
      isDraggingPart = false;
      controls.enabled = true;
      return;
    }

    if(marqueeOn){
      marqueeOn = false;
      marquee.style.display = 'none';
      controls.enabled = true;

      const rect = wrap.getBoundingClientRect();
      const sel = [];
      const r = {x:marqueeRect.x, y:marqueeRect.y, X:marqueeRect.x+marqueeRect.w, Y:marqueeRect.y+marqueeRect.h};
      const v = new THREE.Vector3();
      const p2s = (vec)=>{
        v.copy(vec).project(camera);
        return { sx:(v.x*0.5+0.5)*rect.width, sy:(-v.y*0.5+0.5)*rect.height };
      };

      parts.forEach(p=>{
        const box = new THREE.Box3().setFromObject(p.root);
        const corners = [
          new THREE.Vector3(box.min.x, box.min.y, box.min.z),
          new THREE.Vector3(box.min.x, box.min.y, box.max.z),
          new THREE.Vector3(box.min.x, box.max.y, box.min.z),
          new THREE.Vector3(box.min.x, box.max.y, box.max.z),
          new THREE.Vector3(box.max.x, box.min.y, box.min.z),
          new THREE.Vector3(box.max.x, box.min.y, box.max.z),
          new THREE.Vector3(box.max.x, box.max.y, box.min.z),
          new THREE.Vector3(box.max.x, box.max.y, box.max.z),
        ];
        const inside = corners.every(c=>{
          const s = p2s(c);
          return (s.sx>=r.x && s.sx<=r.X && s.sy>=r.y && s.sy<=r.Y);
        });
        if(inside) sel.push(p);
      });
      if(sel.length) setSelected(sel, ev.ctrlKey || ev.metaKey);
      return;
    }

    if(!moved && activeTab==='model'){
      const hit = hitTest(ev);
      if(hit){
        if(ev.ctrlKey || ev.metaKey) toggleSelectOne(hit);
        else setSelected([hit], false);
      }else{
        selectNone();
      }
    }
  });
}

/* ================== 3D/成長視圖：座標 HUD（射到 z=0 平面） ================== */
function onPointerMoveHud(ev){
  if(activeTab!=='model' && activeTab!=='growth'){ hud.style.display='none'; return; }
  const rect = renderer.domElement.getBoundingClientRect();
  const x = ((ev.clientX - rect.left)/rect.width)*2 - 1;
  const y = -((ev.clientY - rect.top)/rect.height)*2 + 1;
  const ray = new THREE.Raycaster();
  ray.setFromCamera({x,y}, camera);
  const plane = new THREE.Plane(new THREE.Vector3(0,0,1), 0);
  const hit = new THREE.Vector3();
  if(ray.ray.intersectPlane(plane, hit)){
    hud.style.display='block';
    hudX.textContent = hit.x.toFixed(2);
    hudY.textContent = hit.y.toFixed(2);
    hudZ.textContent = hit.z.toFixed(2);
  }else{
    hud.style.display='none';
  }
}

/* =============================== 灰階分析（同前） =============================== */
function ensureLayerAnalysis(i){
  const rec = baseSlices[i];
  if(!rec || rec.analysis) return;

  const mask = rec.mask;
  const w = mask.width, h = mask.height;
  const mctx = mask.getContext('2d');
  const md = mctx.getImageData(0,0,w,h).data;

  const bin = new Uint8Array(w*h);
  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      const idx = (y*w + x)*4;
      bin[y*w + x] = (md[idx+3] > 0) ? 1 : 0;
    }
  }

  const outside0 = new Uint8Array(w*h);
  const qx = new Int32Array(w*h), qy=new Int32Array(w*h); let qh=0, qt=0;
  function push(x,y){ qx[qt]=x; qy[qt]=y; qt++; }
  function pop(){ const x=qx[qh], y=qy[qh]; qh++; return [x,y]; }
  for(let x=0;x<w;x++){
    if(bin[x]===0){ outside0[x]=1; push(x,0); }
    if(bin[(h-1)*w+x]===0){ outside0[(h-1)*w+x]=1; push(x,h-1); }
  }
  for(let y=0;y<h;y++){
    if(bin[y*w]===0){ outside0[y*w]=1; push(0,y); }
    if(bin[y*w+(w-1)]===0){ outside0[y*w+(w-1)]=1; push(w-1,y); }
  }
  while(qh<qt){
    const [cx,cy]=pop();
    const nbr=[[1,0],[-1,0],[0,1],[0,-1]];
    for(const [dx,dy] of nbr){
      const nx=cx+dx, ny=cy+dy;
      if(nx<0||ny<0||nx>=w||ny>=h) continue;
      const i2=ny*w+nx;
      if(bin[i2]===0 && !outside0[i2]){ outside0[i2]=1; push(nx,ny); }
    }
  }
  const hole0 = new Uint8Array(w*h);
  for(let i2=0;i2<w*h;i2++){ hole0[i2] = (bin[i2]===0 && !outside0[i2]) ? 1 : 0; }

  const outerBoundary = new Uint8Array(w*h);
  const innerBoundary = new Uint8Array(w*h);
  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      const i2=y*w+x;
      if(bin[i2]===0) continue;
      let nbOutside=false, nbHole=false;
      for(let dy=-1;dy<=1;dy++){
        for(let dx=-1;dx<=1;dx++){
          const nx=x+dx, ny=y+dy;
          if(nx<0||ny<0||nx>=w||ny>=h) { nbOutside=true; continue; }
          if(outside0[ny*w+nx]===1) nbOutside=true;
          if(hole0[ny*w+nx]===1) nbHole=true;
        }
      }
      outerBoundary[i2] = nbOutside ? 1 : 0;
      innerBoundary[i2] = nbHole    ? 1 : 0;
    }
  }

  const INF=1e9;
  function edtFromSources(sourcesMask){
    const dist = new Float32Array(w*h);
    for(let i2=0;i2<w*h;i2++){ dist[i2] = (sourcesMask[i2]===1) ? 0 : INF; }
    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const i2=y*w+x; let v=dist[i2];
        if(x>0)            v = Math.min(v, dist[i2-1]     + 1);
        if(y>0)            v = Math.min(v, dist[i2-w]     + 1);
        if(x>0 && y>0)     v = Math.min(v, dist[i2-w-1]   + Math.SQRT2);
        if(x<w-1 && y>0)   v = Math.min(v, dist[i2-w+1]   + Math.SQRT2);
        dist[i2]=v;
      }
    }
    for(let y=h-1;y>=0;y--){
      for(let x=0;x<w;x++){
        const i2=y*w+x; let v=dist[i2];
        if(x<w-1)          v = Math.min(v, dist[i2+1]     + 1);
        if(y<h-1)          v = Math.min(v, dist[i2+w]     + 1);
        if(x<w-1 && y<h-1) v = Math.min(v, dist[i2+w+1]   + Math.SQRT2);
        if(x>0 && y<h-1)   v = Math.min(v, dist[i2+w-1]   + Math.SQRT2);
        dist[i2]=v;
      }
    }
    return dist;
  }

  const distOuter = edtFromSources(outerBoundary);
  const distInner = edtFromSources(innerBoundary);

  const labels = new Int32Array(w*h).fill(-1);
  const regions = [];
  let qx2 = new Int32Array(w*h), qy2=new Int32Array(w*h); let qh2=0, qt2=0;
  function push2(x,y){ qx2[qt2]=x; qy2[qt2]=y; qt2++; }
  function pop2(){ const x=qx2[qh2], y=qy2[qh2]; qh2++; return [x,y]; }
  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      const id0 = y*w+x;
      if(bin[id0]===0 || labels[id0]!==-1) continue;
      let area=0, sx=0, sy=0; let hasHole=false; let maxOuter=1;
      push2(x,y); labels[id0]=regions.length;
      while(qh2<qt2){
        const [cx,cy]=pop2();
        area++; sx+=cx; sy+=cy;
        const i2=cy*w+cx;
        if(distOuter[i2]<INF && distOuter[i2]>maxOuter) maxOuter=distOuter[i2];
        for(let dy=-1;dy<=1;dy++){
          for(let dx=-1;dx<=1;dx++){
            const nx=cx+dx, ny=cy+dy;
            if(nx<0||ny<0||nx>=w||ny>=h) continue;
            if(outside0[ny*w+nx]===1){} 
            if(hole0[ny*w+nx]===1) hasHole = true;
          }
        }
        if(cx>0    && bin[cy*w+cx-1]===1 && labels[cy*w+cx-1]===-1){ labels[cy*w+cx-1]=labels[id0]; push2(cx-1,cy); }
        if(cx<w-1  && bin[cy*w+cx+1]===1 && labels[cy*w+cx+1]===-1){ labels[cy*w+cx+1]=labels[id0]; push2(cx+1,cy); }
        if(cy>0    && bin[(cy-1)*w+cx]===1 && labels[(cy-1)*w+cx]===-1){ labels[(cy-1)*w+cx]=labels[id0]; push2(cx,cy-1); }
        if(cy<h-1  && bin[(cy+1)*w+cx]===1 && labels[(cy+1)*w+cx]===-1){ labels[(cy+1)*w+cx]=labels[id0]; push2(cx,cy+1); }
      }
      regions.push({ id:regions.length, area, cx:sx/area, cy:sy/area, hasHole, maxOuter });
      qh2=0; qt2=0;
    }
  }

  rec.analysis = { w,h, bin, labels, regions, distOuter, distInner };
}

function ensurePartAnalysis(i, pid){
  const rec = baseSlices[i];
  rec.partAnalyses ||= new Map();
  if(rec.partAnalyses.has(pid)) return;
  const pm = rec.parts.find(p=>p.partId===pid);
  if(!pm) { rec.partAnalyses.set(pid, null); return; }

  const w = pm.mask.width, h = pm.mask.height;
  const ctx = pm.mask.getContext('2d');
  const md = ctx.getImageData(0,0,w,h).data;

  const bin = new Uint8Array(w*h);
  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      const idx = (y*w+x)*4;
      bin[y*w+x] = (md[idx+3] > 0) ? 1 : 0;
    }
  }

  const outside0 = new Uint8Array(w*h);
  const qx = new Int32Array(w*h), qy=new Int32Array(w*h); let qh=0, qt=0;
  function push(x,y){ qx[qt]=x; qy[qt]=y; qt++; }
  function pop(){ const x=qx[qh], y=qy[qh]; qh++; return [x,y]; }
  for(let x=0;x<w;x++){
    if(bin[x]===0){ outside0[x]=1; push(x,0); }
    if(bin[(h-1)*w+x]===0){ outside0[(h-1)*w+x]=1; push(x,h-1); }
  }
  for(let y=0;y<h;y++){
    if(bin[y*w]===0){ outside0[y*w]=1; push(0,y); }
    if(bin[y*w+(w-1)]===0){ outside0[y*w+(w-1)]=1; push(w-1,y); }
  }
  while(qh<qt){
    const [cx,cy]=pop();
    const nbr=[[1,0],[-1,0],[0,1],[0,-1]];
    for(const [dx,dy] of nbr){
      const nx=cx+dx, ny=cy+dy;
      if(nx<0||ny<0||nx>=w||ny>=h) continue;
      const i2=ny*w+nx;
      if(bin[i2]===0 && !outside0[i2]){ outside0[i2]=1; push(nx,ny); }
    }
  }
  const hole0 = new Uint8Array(w*h);
  for(let i2=0;i2<w*h;i2++){ hole0[i2] = (bin[i2]===0 && !outside0[i2]) ? 1 : 0; }

  const outerBoundary = new Uint8Array(w*h);
  const innerBoundary = new Uint8Array(w*h);
  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      const i2=y*w+x;
      if(bin[i2]===0) continue;
      let nbOutside=false, nbHole=false;
      for(let dy=-1;dy<=1;dy++){
        for(let dx=-1;dx<=1;dx++){
          const nx=x+dx, ny=y+dy;
          if(nx<0||ny<0||nx>=w||ny>=h) { nbOutside=true; continue; }
          if(outside0[ny*w+nx]===1) nbOutside=true;
          if(hole0[ny*w+nx]===1) nbHole=true;
        }
      }
      outerBoundary[i2] = nbOutside ? 1 : 0;
      innerBoundary[i2] = nbHole    ? 1 : 0;
    }
  }

  const INF = 1e9;
  function edtFromSources(src){
    const dist = new Float32Array(w*h);
    for(let i2=0;i2<w*h;i2++) dist[i2] = (src[i2]===1) ? 0 : INF;
    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const i2=y*w+x; let v=dist[i2];
        if(x>0) v=Math.min(v,dist[i2-1]+1);
        if(y>0) v=Math.min(v,dist[i2-w]+1);
        if(x>0&&y>0) v=Math.min(v,dist[i2-w-1]+Math.SQRT2);
        if(x<w-1&&y>0) v=Math.min(v,dist[i2-w+1]+Math.SQRT2);
        dist[i2]=v;
      }
    }
    for(let y=h-1;y>=0;y--){
      for(let x=0;x<w;x++){
        const i2=y*w+x; let v=dist[i2];
        if(x<w-1) v=Math.min(v,dist[i2+1]+1);
        if(y<h-1) v=Math.min(v,dist[i2+w]+1);
        if(x<w-1&&y<h-1) v=Math.min(v,dist[i2+w+1]+Math.SQRT2);
        if(x>0&&y<h-1) v=Math.min(v,dist[i2+w-1]+Math.SQRT2);
        dist[i2]=v;
      }
    }
    return dist;
  }
  const distOuter = edtFromSources(outerBoundary);
  const distInner = edtFromSources(innerBoundary);

  const labels = new Int32Array(w*h).fill(-1);
  const regions = [];
  let qx2 = new Int32Array(w*h), qy2=new Int32Array(w*h); let qh2=0, qt2=0;
  function push2(x,y){ qx2[qt2]=x; qy2[qt2]=y; qt2++; }
  function pop2(){ const x=qx2[qh2], y=qy2[qh2]; qh2++; return [x,y]; }
  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      const id0=y*w+x; if(bin[id0]===0 || labels[id0]!==-1) continue;
      let area=0,sx=0,sy=0,hasHole=false,maxOuter=1;
      push2(x,y); labels[id0]=regions.length;
      while(qh2<qt2){
        const [cx,cy]=pop2();
        area++; sx+=cx; sy+=cy;
        const i2=cy*w+cx;
        if(distOuter[i2]<1e9 && distOuter[i2]>maxOuter) maxOuter=distOuter[i2];
        for(let dy=-1;dy<=1;dy++){
          for(let dx=-1;dx<=1;dx++){
            const nx=cx+dx, ny=cy+dy;
            if(nx<0||ny<0||nx>=w||ny>=h) continue;
            if(hole0[ny*w+nx]===1) hasHole=true;
          }
        }
        if(cx>0    && bin[cy*w+cx-1]===1 && labels[cy*w+cx-1]===-1){ labels[cy*w+cx-1]=labels[id0]; push2(cx-1,cy); }
        if(cx<w-1  && bin[cy*w+cx+1]===1 && labels[cy*w+cx+1]===-1){ labels[cy*w+cx+1]=labels[id0]; push2(cx+1,cy); }
        if(cy>0    && bin[(cy-1)*w+cx]===1 && labels[(cy-1)*w+cx]===-1){ labels[(cy-1)*w+cx]=labels[id0]; push2(cx,cy-1); }
        if(cy<h-1  && bin[(cy+1)*w+cx]===1 && labels[(cy+1)*w+cx]===-1){ labels[(cy+1)*w+cx]=labels[id0]; push2(cx,cy+1); }
      }
      regions.push({id:regions.length, area, cx:sx/area, cy:sy/area, hasHole, maxOuter});
      qh2=0; qt2=0;
    }
  }
  rec.partAnalyses.set(pid, { w,h, bin, labels, regions, distOuter, distInner });
}

function applyConcentricGrayscaleSmart(ctx, recLike, st, an, drawWhiteBG){
  const { w, h, bin, labels, regions, distOuter, distInner } = an;
  if(drawWhiteBG){
    ctx.save(); ctx.globalCompositeOperation='destination-over';
    ctx.fillStyle='#ffffff'; ctx.fillRect(0,0,recLike.frameW||w,recLike.frameH||h);
    ctx.restore();
  }
  const x0=recLike.x||0, y0=recLike.y||0;
  const img = ctx.getImageData(x0, y0, w, h);
  const d = img.data;

  const steps = Math.max(2, Math.min(10, st.gray2Steps|0));
  const levels = steps - 1;
  const useCentroid = (st.gray2Mode==='centroid-in' || st.gray2Mode==='centroid-out');
  const invertEdge   = (st.gray2Mode==='edge-out');
  const invertCentroid = (st.gray2Mode==='centroid-out');

  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      const i = y*w+x; if(bin[i]===0) continue;
      const pi = i*4;

      let t = 0;
      if(useCentroid){
        const rid = labels[i], r = regions[rid];
        const rr = Math.hypot(x - r.cx, y - r.cy);
        let maxR = r._maxR; if(!maxR){
          let m=1;
          for(let yy=0;yy<h;yy++){
            for(let xx=0;xx<w;xx++){
              const j=yy*w+xx; if(bin[j]===0||labels[j]!==rid) continue;
              const cand = Math.hypot(xx - r.cx, yy - r.cy);
              if(cand>m) m=cand;
            }
          }
          r._maxR = m; maxR=m;
        }else maxR = r._maxR;

        t = rr / (maxR||1);
        if(invertCentroid) t = 1 - t;
      }else{
        const rid = labels[i], r = regions[rid];
        const doOuter = distOuter[i];
        const doInner = distInner[i];
        let denom;
        if(r.hasHole && doInner<Infinity){
          denom = doOuter + doInner;
        }else{
          denom = r.maxOuter || 1;
        }
        t = (denom>0 && doOuter<Infinity) ? (doOuter / denom) : 0;
        if(invertEdge) t = 1 - t;
      }

      t = Math.max(0, Math.min(1, t));
      let band = Math.floor(t * levels);
      band = Math.max(0, Math.min(levels-1, band));
      const gray = Math.round((band+1) * 255 / steps);
      d[pi]=d[pi+1]=d[pi+2]=gray; d[pi+3]=255;
    }
  }
  ctx.putImageData(img, x0, y0);
}

/* =============================== 其餘公用 =============================== */
function updateLayerInfo(cur,total){
  document.getElementById('current-layer').textContent = cur;
  document.getElementById('total-layers').textContent = total;
}
function rgbToHex(r,g,b){ const h=v=>v.toString(16).padStart(2,'0'); return `#${h(r)}${h(g)}${h(b)}`; }
function sanitizeName(s){
  return String(s||'').replace(/[\\/:*?"<>|]+/g,'_').replace(/\s+/g,'_').replace(/_+/g,'_').replace(/^_+|_+$/g,'').slice(0,100)||'output';
}
function isCtxEmpty(ctx){
  const w = ctx.canvas.width, h = ctx.canvas.height;
  if(!w||!h) return true;
  const data = ctx.getImageData(0,0,w,h).data;
  for(let i=3;i<data.length;i+=4) if(data[i]!==0) return false;
  return true;
}
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function choosePxPerUnitPlatform(w, h){
  const targetMaxPx = getPxCap();
  const maxSideMm = Math.max(w, h);
  if(maxSideMm<=0) return DEFAULT_PX_PER_UNIT;
  const pxPer = targetMaxPx / maxSideMm;
  return Math.max(0.5, pxPer);
}

/* 匯出尺寸（依平台比例） */
const MIN_EXPORT_PX = 256;
const MAX_EXPORT_PX = 4096;

function getExportWidthRaw(){
  if(!exportWidthInput) return 2048;
  let w = parseInt(exportWidthInput.value || '2048', 10);
  if(isNaN(w) || w<=0) w = 2048;
  w = clamp(w, MIN_EXPORT_PX, MAX_EXPORT_PX);
  exportWidthInput.value = String(w);
  return w;
}

function updateScaleBarPxPerUnitFromWidth(w){
  const widthMm = platform.width || 1;
  pxPerUnitScaleBar = w / widthMm;
}

function updateScaleBarPxPerUnit(){
  const w = getExportWidthRaw();
  updateScaleBarPxPerUnitFromWidth(w);
}

function syncExportFromWidth(){
  const w = getExportWidthRaw();
  const aspect = (platform.height>0 && platform.width>0) ? (platform.height/platform.width) : 1;
  if(exportHeightInput){
    let h = w * aspect;
    h = clamp(Math.round(h / 128) * 128 || 256, MIN_EXPORT_PX, MAX_EXPORT_PX);
    exportHeightInput.value = String(h);
  }
  updateScaleBarPxPerUnitFromWidth(w);
  if(baseSlices.length>0) scheduleRenderSlice(currentSliceIndex);
}

function syncExportFromHeight(){
  if(!exportHeightInput) return;
  let h = parseInt(exportHeightInput.value || '2048',10);
  if(isNaN(h) || h<=0) h=2048;
  h = clamp(h, MIN_EXPORT_PX, MAX_EXPORT_PX);
  exportHeightInput.value = String(h);
  const aspectInv = (platform.height>0 && platform.width>0) ? (platform.width/platform.height) : 1;
  const w = clamp(Math.round(h * aspectInv / 128) * 128 || 256, MIN_EXPORT_PX, MAX_EXPORT_PX);
  if(exportWidthInput) exportWidthInput.value = String(w);
  updateScaleBarPxPerUnitFromWidth(w);
  if(baseSlices.length>0) scheduleRenderSlice(currentSliceIndex);
}

function getExportSizes(){
  const w = getExportWidthRaw();
  let h = w;
  if(exportHeightInput){
    h = parseInt(exportHeightInput.value || '0',10);
    if(isNaN(h) || h<=0){
      const aspect = (platform.height>0 && platform.width>0) ? (platform.height/platform.width) : 1;
      h = w * aspect;
    }
    h = clamp(Math.round(h / 128) * 128 || 256, MIN_EXPORT_PX, MAX_EXPORT_PX);
    exportHeightInput.value = String(h);
  }
  return {width:w, height:h};
}

if(exportWidthInput){
  exportWidthInput.addEventListener('change', ()=> syncExportFromWidth());
}
if(exportHeightInput){
  exportHeightInput.addEventListener('change', ()=> syncExportFromHeight());
}

function getMeshDisplayColor(mesh){
  const mat = mesh.material;
  if(Array.isArray(mat)){
    for(const m of mat){ if(m?.map){ const hx=avgColorFromTexture(m.map); if(hx) return hx; } }
  }else if(mat?.map){
    const hx = avgColorFromTexture(mat.map); if(hx) return hx;
  }
  const vtx = avgVertexColor(mesh.geometry); if(vtx) return vtx;
  const matColor = (Array.isArray(mat) ? (mat.find(m=>m?.color)?.color) : mat?.color);
  if(matColor) return '#'+matColor.getHexString();
  return defaultSliceColor || '#e74c3c';
}
function avgVertexColor(geom){
  const attr=geom?.attributes?.color; if(!attr) return null;
  let r=0,g=0,b=0,n=attr.count; if(!n) return null;
  for(let i=0;i<n;i++){ r+=attr.getX(i); g+=attr.getY(i); b+=attr.getZ(i); }
  r=Math.round((r/n)*255); g=Math.round((g/n)*255); b=Math.round((b/n)*255);
  return rgbToHex(r,g,b);
}
function avgColorFromTexture(tex){
  if(!tex) return null; if(textureAvgCache.has(tex)) return textureAvgCache.get(tex);
  let hex=null;
  try{
    const img=tex.image;
    if(img.data&&img.width&&img.height){
      const w=Math.min(64,img.width), h=Math.min(64,img.height);
      const sx=Math.floor(img.width/w), sy=Math.floor(img.height/h);
      let r=0,g=0,b=0,c=0; const data=img.data;
      for(let y=0;y<img.height;y+=sy){
        for(let x=0;x<img.width;x+=sx){
          const i=(y*img.width+x)*4, a=data[i+3]; if(a<10) continue;
          r+=data[i]; g+=data[i+1]; b+=data[i+2]; c++;
        }
      }
      if(c>0){ r=Math.round(r/c); g=Math.round(g/c); b=Math.round(b/c); hex=rgbToHex(r,g,b); }
    }else{
      const w=64,h=64; const c=document.createElement('canvas'); c.width=w; c.height=h;
      const ctx=c.getContext('2d'); ctx.drawImage(img,0,0,w,h);
      const d=ctx.getImageData(0,0,w,h).data; let r=0,g=0,b=0,cnt=0;
      for(let i=0;i<d.length;i+=4){
        const a=d[i+3]; if(a<10) continue;
        r+=d[i]; g+=d[i+1]; b+=d[i+2]; cnt++;
      }
      if(cnt>0){ r=Math.round(r/cnt); g=Math.round(g/cnt); b=Math.round(b/cnt); hex=rgbToHex(r,g,b); }
    }
  }catch(_){}
  textureAvgCache.set(tex, hex); return hex;
}

/* =============================== 切片：平台固定視窗 =============================== */
function getAutoSnap(w,h){
  const base=Math.max(256, Math.max(w||1,h||1));
  const snap=0.10*(1024/base);
  return Math.max(0.02, Math.min(0.35, snap));
}
function polygonArea(poly){
  let s=0;
  for(let i=0;i<poly.length;i++){
    const [x1,y1]=poly[i],[x2,y2]=poly[(i+1)%poly.length];
    s+=x1*y2-x2*y1;
  }
  return s*0.5;
}

//* =============================== 切片：線段直接光柵化（保孔洞） =============================== */
/* 用 even-odd 掃描線把「切平面線段」直接轉成 mask：不需要重建 polygon loops，孔洞不會被串掉 */

function rasterizeSegmentsToMaskCanvas(segs, W, H){
  if(!segs || segs.length < 2) return null;

  // 量化步距：太大會把薄壁/小孔黏在一起；太小會導致端點對不上
  // 這裡把它限制在 [0.001, 0.02] pixel
  const qStep = Math.max(0.001, Math.min(0.02, getAutoSnap(W, H)));

  const qKey = (p)=>{
    const ix = Math.round(p[0] / qStep);
    const iy = Math.round(p[1] / qStep);
    return `${ix},${iy}`;
  };
  const fromKey = (k)=>{
    const t = k.split(',');
    const ix = parseInt(t[0],10), iy = parseInt(t[1],10);
    return [ix*qStep, iy*qStep];
  };

  // 1) 去重複線段（避免 parity 被多算，孔洞反而被填掉）
  const edgeSet = new Set();
  const edges = []; // [x0,y0,x1,y1]
  for(const s of segs){
    if(!s || s.length < 2) continue;
    const a = s[0], b = s[1];
    if(!a || !b) continue;
    if(!isFinite(a[0]) || !isFinite(a[1]) || !isFinite(b[0]) || !isFinite(b[1])) continue;

    const ka = qKey(a), kb = qKey(b);
    if(ka === kb) continue;
    const ek = (ka < kb) ? `${ka}|${kb}` : `${kb}|${ka}`;
    if(edgeSet.has(ek)) continue;
    edgeSet.add(ek);

    const A = fromKey(ka), B = fromKey(kb);
    const dx = A[0]-B[0], dy = A[1]-B[1];
    if(dx*dx + dy*dy < 1e-8) continue; // 太短的丟掉

    edges.push([A[0],A[1],B[0],B[1]]);
  }
  if(edges.length < 2) return null;

  // 2) 建 Edge Table（Active Edge Table）
  const buckets = Array.from({length:H}, ()=>[]);
  for(const e of edges){
    let x0=e[0], y0=e[1], x1=e[2], y1=e[3];

    // 忽略水平邊（避免掃描線重複交點）
    if(Math.abs(y0 - y1) < 1e-9) continue;

    // 保證 y0 < y1
    if(y0 > y1){
      const tx=x0; x0=x1; x1=tx;
      const ty=y0; y0=y1; y1=ty;
    }

    // 完全不在畫布高度範圍附近，略過
    if(y1 < -1 || y0 > H+1) continue;

    const invSlope = (x1 - x0) / (y1 - y0);

    // 掃描線用 pixel center：y + 0.5
    // 採用「上端點不含」規則：y in [y0, y1)
    let yStart = Math.ceil(y0 - 0.5);
    let yEnd   = Math.ceil(y1 - 0.5); // exclusive

    yStart = clamp(yStart, 0, H-1);
    yEnd   = clamp(yEnd,   0, H);

    if(yStart >= yEnd) continue;

    const yCenter = yStart + 0.5;
    const xAtStart = x0 + (yCenter - y0) * invSlope;

    buckets[yStart].push({ yEnd, x: xAtStart, invSlope });
  }

  // 3) 光柵化：只寫 alpha（mask = 黑色+alpha）
  const canvas = document.createElement('canvas');
  canvas.width = W; canvas.height = H;
  const ctx = canvas.getContext('2d');
  const img = ctx.createImageData(W, H);
  const data = img.data;

  const active = [];
  let any = false;

  for(let y=0; y<H; y++){
    const add = buckets[y];
    if(add && add.length) active.push(...add);

    // 移除結束的邊
    for(let i=active.length-1; i>=0; i--){
      if(y >= active[i].yEnd) active.splice(i,1);
    }

    if(active.length >= 2){
      active.sort((a,b)=> a.x - b.x);

      const rowBase = y * W * 4;

      // even-odd：兩兩配對填滿
      for(let i=0; i+1<active.length; i+=2){
        let xA = active[i].x;
        let xB = active[i+1].x;
        if(xA > xB){ const t=xA; xA=xB; xB=t; }

        // 對應 pixel center：x+0.5
        let xs = Math.ceil(xA - 0.5);
        let xe = Math.floor(xB - 0.5);

        if(xe < 0 || xs >= W) continue;
        xs = clamp(xs, 0, W-1);
        xe = clamp(xe, 0, W-1);
        if(xs > xe) continue;

        any = true;

        // 只填 alpha channel（RGB 會保持 0）
        let p = rowBase + xs*4 + 3;
        const end = rowBase + xe*4 + 3;
        for(; p<=end; p+=4) data[p] = 255;
      }
    }

    // 下一掃描線：x += invSlope
    for(const e of active) e.x += e.invSlope;
  }

  if(!any) return null;

  ctx.putImageData(img, 0, 0);
  return canvas;
}



function getRootPartIdForMesh(mesh){
  let root = mesh;
  while(root && !root.userData?.partId) root = root.parent;
  return root?.userData?.partId || null;
}

/* 取得實際有效樣式 */
function ensureLayerSettings(i){ if(!layerSettings[i]) layerSettings[i]=defLayerSetting(); return layerSettings[i]; }
function bumpLayerVersion(i){ const st=ensureLayerSettings(i); st._ver = ++verSeq; }
function bumpPartVersion(key){ const st=partSliceSettings.get(key)||{}; st._ver = ++verSeq; partSliceSettings.set(key, st); return st; }

function effectiveStyleForPart(layerIndex, part){
  const stLayer = ensureLayerSettings(layerIndex);
  const lv = stLayer._ver || 0;

  const key = `${layerIndex}:${part.partId}`;
  const pst = partSliceSettings.get(key);
  const pv = pst?._ver||-1;

  if(pst && pv >= lv){
    return { source:'part', ...pst };
  }else{
    let color = stLayer.color;
    if(lv===0 && usePartColorsChk.checked){
      color = part.color || color;
    }
    return {
      source:'layer',
      color,
      gray2Enabled:stLayer.gray2Enabled,
      gray2Steps:stLayer.gray2Steps,
      gray2Mode:stLayer.gray2Mode,
      pixelLevel:stLayer.pixelLevel
    };
  }
}

/* 合成圖層 */
function compositeLayerToCanvas(index, {transparent=false, includeScaleBar=false}={}){
  if(index<0 || index>=baseSlices.length) return null;
  const rec=baseSlices[index]; const w=rec.frameW, h=rec.frameH;

  const canvas=document.createElement('canvas'); canvas.width=w; canvas.height=h;
  const ctx=canvas.getContext('2d');

  const layerA=document.createElement('canvas'); layerA.width=w; layerA.height=h;
  const layerB=document.createElement('canvas'); layerB.width=w; layerB.height=h;
  const ctxA=layerA.getContext('2d'), ctxB=layerB.getContext('2d');

  const stLayer = ensureLayerSettings(index);

  baseSlices[index].parts.forEach(part=>{
    const eff = effectiveStyleForPart(index, part);
    const targetCtx = (eff.source==='part') ? ctxA : ctxB;

    const factor = Math.max(1, Math.floor(1 + (eff.pixelLevel||0)));
    const pw=part.w*factor, ph=part.h*factor;

    const tmp=document.createElement('canvas'); tmp.width=pw; tmp.height=ph;
    const tctx=tmp.getContext('2d');
    tctx.fillStyle = eff.color || part.color || '#e74c3c';
    tctx.fillRect(0,0,pw,ph);
    tctx.globalCompositeOperation='destination-in';
    tctx.drawImage(part.mask, 0,0, part.w, part.h, 0,0, pw, ph);
    tctx.globalCompositeOperation='source-over';

    if(eff.source==='part' && eff.gray2Enabled){
      ensurePartAnalysis(index, part.partId);
      const an = baseSlices[index].partAnalyses.get(part.partId);
      const tmpBack=document.createElement('canvas'); tmpBack.width=part.w; tmpBack.height=part.h;
      const tb=tmpBack.getContext('2d'); tb.drawImage(tmp,0,0,pw,ph,0,0,part.w,part.h);
      applyConcentricGrayscaleSmart(tb, {x:0,y:0,frameW:part.w,frameH:part.h}, eff, an, false);
      targetCtx.drawImage(tmpBack, part.x, part.y);
    }else{
      targetCtx.drawImage(tmp, 0,0,pw,ph, part.x, part.y, part.w, part.h);
    }
  });

  if(stLayer.gray2Enabled){
    ensureLayerAnalysis(index);
    applyConcentricGrayscaleSmart(ctxB, rec, stLayer, rec.analysis, false);
  }

  if(!transparent){
    ctx.fillStyle='#ffffff';
    ctx.fillRect(0,0,w,h);
  }
  ctx.drawImage(layerB,0,0);
  ctx.drawImage(layerA,0,0);

  if(includeScaleBar && scaleBarEnabled){
    drawScaleBar(ctx, w, h);
  }
  return canvas;
}

/* 產生切片主流程 =============================== */
async function generateSlices(){
  const selection = getSelectedMeshes();
  const selMeshes = (selection.length>0) ? selection : getAllMeshes();
  if(selMeshes.length===0){ alert('請先載入模型。'); return; }

  sliceThickness = parseFloat(layerHeightInput.value);
  if(isNaN(sliceThickness) || sliceThickness<=0){ alert('請輸入正確層厚'); return; }

  showProgress('切片中…', 0);
  await nextFrame();

  baseSlices=[];
  layerSettings=[];
  unloadAllGrowthTextures();
  growthGroup.clear(); growthBuilt=false; growthGroup.visible=false;
  growthLoaded.clear();

  let box = new THREE.Box3();
  selMeshes.forEach((m,idx)=>{
    const b = new THREE.Box3().setFromObject(m);
    if(idx===0) box.copy(b); else box.union(b);
  });

  const minZ=box.min.z, maxZ=box.max.z;
  const zRangeLen = Math.max(0, maxZ - minZ);
  const layerCount = Math.max(1, Math.ceil(zRangeLen / sliceThickness));

  sliceBounds.zMin = minZ;

  const plateW = Math.max(1, parseFloat(plateWInput.value)||platform.width);
  const plateH = Math.max(1, parseFloat(plateHInput.value)||platform.height);
  platform.width = plateW; platform.height = plateH;
  updatePlatformVisual();
  syncExportFromWidth(); // 平台變更後，同步輸出尺寸與比例尺

  const pxPerUnit = choosePxPerUnitPlatform(plateW, plateH);
  pxPerUnitGlobal = pxPerUnit;
  const frameW = clamp(Math.round(plateW * pxPerUnit), MIN_CANVAS, MAX_CANVAS);
  const frameH = clamp(Math.round(plateH * pxPerUnit), MIN_CANVAS, MAX_CANVAS);
  frameWGlobal = frameW; frameHGlobal = frameH;

  const xMin = -plateW/2, xMax = plateW/2;
  const yMin = -plateH/2, yMax = plateH/2;
  sliceBounds.xMin=xMin; sliceBounds.xMax=xMax;
  sliceBounds.yMin=yMin; sliceBounds.yMax=yMax;

  const xRange=Math.max(1e-9, xMax-xMin);
  const yRange=Math.max(1e-9, yMax-yMin);
  const projectXY = (v)=> {
    const u = (v.x - xMin) / xRange * (frameW - 1);
    const r = (v.y - yMin) / yRange * (frameH - 1);
    return [u,r];
  };

  const meshes = selMeshes;
  const v0 = new THREE.Vector3(), v1=new THREE.Vector3(), v2=new THREE.Vector3();

  function collectAtPlaneForMesh(mesh, zPlane, segsOut){
  // ✅ 修正：避免「整個共平面三角形」把孔洞補死
  // 規則：
  // 1) 三點都在切平面上（整片共平面三角形）→ 忽略（不加入輪廓）
  // 2) 恰好兩點在切平面上（共平面邊）→ 只加入那條邊（作為輪廓段）
  // 3) 其他情況 → 只取真正穿越平面的交線段

  const EPSZ = 1e-7;

  const geom = mesh.geometry;
  const pos  = geom.attributes.position;
  const idx  = geom.index ? geom.index.array : null;
  const matW = mesh.matrixWorld;

  const triCount = idx ? Math.floor(idx.length / 3) : Math.floor(pos.count / 3);

  // 小工具：把投影點去重（避免同一個交點被重複加入）
  const addUniquePt = (arr, p) => {
    for(const q of arr){
      if(Math.abs(p[0]-q[0]) < 1e-4 && Math.abs(p[1]-q[1]) < 1e-4) return;
    }
    arr.push(p);
  };

  // 小工具：從多個交點中挑一對距離最遠的，當作交線段
  const pickFarthestPair = (pts) => {
    let bestA = pts[0], bestB = pts[1];
    let bestD = -1;
    for(let i=0;i<pts.length;i++){
      for(let j=i+1;j<pts.length;j++){
        const dx = pts[i][0]-pts[j][0];
        const dy = pts[i][1]-pts[j][1];
        const d2 = dx*dx + dy*dy;
        if(d2 > bestD){
          bestD = d2;
          bestA = pts[i];
          bestB = pts[j];
        }
      }
    }
    return [bestA, bestB];
  };

  for(let t=0; t<triCount; t++){
    // 讀三角形三點（世界座標）
    if(idx){
      v0.fromBufferAttribute(pos, idx[t*3+0]).applyMatrix4(matW);
      v1.fromBufferAttribute(pos, idx[t*3+1]).applyMatrix4(matW);
      v2.fromBufferAttribute(pos, idx[t*3+2]).applyMatrix4(matW);
    }else{
      v0.fromBufferAttribute(pos, t*3+0).applyMatrix4(matW);
      v1.fromBufferAttribute(pos, t*3+1).applyMatrix4(matW);
      v2.fromBufferAttribute(pos, t*3+2).applyMatrix4(matW);
    }

    const d0 = v0.z - zPlane;
    const d1 = v1.z - zPlane;
    const d2 = v2.z - zPlane;

    const a0 = Math.abs(d0) < EPSZ;
    const a1 = Math.abs(d1) < EPSZ;
    const a2 = Math.abs(d2) < EPSZ;

    // (1) 整片共平面 → 忽略（最常造成孔洞被補死）
    if(a0 && a1 && a2){
      continue;
    }

    // (2) 恰好兩點共平面 → 只加那條邊
    if(a0 && a1 && !a2){
      const p0 = projectXY(v0);
      const p1 = projectXY(v1);
      if(Math.hypot(p0[0]-p1[0], p0[1]-p1[1]) > 1e-4) segsOut.push([p0,p1]);
      continue;
    }
    if(a1 && a2 && !a0){
      const p1 = projectXY(v1);
      const p2 = projectXY(v2);
      if(Math.hypot(p1[0]-p2[0], p1[1]-p2[1]) > 1e-4) segsOut.push([p1,p2]);
      continue;
    }
    if(a2 && a0 && !a1){
      const p2 = projectXY(v2);
      const p0 = projectXY(v0);
      if(Math.hypot(p2[0]-p0[0], p2[1]-p0[1]) > 1e-4) segsOut.push([p2,p0]);
      continue;
    }

    // (3) 一般情況：只取真正穿越平面的交點
    const ipts = [];

    const addProj = (vecLike) => {
      addUniquePt(ipts, projectXY(vecLike));
    };

    const edgeInter = (A, dA, B, dB) => {
      const onA = Math.abs(dA) < EPSZ;
      const onB = Math.abs(dB) < EPSZ;

      // 共平面邊（兩端都在平面上）已在「兩點共平面」處理過，這裡跳過
      if(onA && onB) return;

      if(onA){ addProj(A); return; }
      if(onB){ addProj(B); return; }

      // 同側不相交
      if(dA * dB > 0) return;

      // 穿越：線性插值
      const t = dA / (dA - dB); // 0..1
      if(t < -1e-6 || t > 1+1e-6) return;

      const tt = Math.max(0, Math.min(1, t));
      const ix = A.x + (B.x - A.x) * tt;
      const iy = A.y + (B.y - A.y) * tt;

      addUniquePt(ipts, projectXY({x:ix, y:iy}));
    };

    edgeInter(v0,d0,v1,d1);
    edgeInter(v1,d1,v2,d2);
    edgeInter(v2,d2,v0,d0);

    if(ipts.length < 2) continue;

    // 若因為數值原因出現 3 個點，取距離最遠的一對當交線段
    const [pa, pb] = (ipts.length === 2) ? [ipts[0], ipts[1]] : pickFarthestPair(ipts);

    if(Math.hypot(pa[0]-pb[0], pa[1]-pb[1]) > 1e-4){
      segsOut.push([pa, pb]);
    }
  }
}


  /* 只用 loops 填滿，避免 coplanar triangles 把孔洞補死 */
  function drawLoopsAndPolys(ctx, loops){
    ctx.beginPath();
    loops.forEach(loop=>{
      if(loop.length<3) return;
      ctx.moveTo(loop[0][0], loop[0][1]);
      for(let i=1;i<loop.length;i++) ctx.lineTo(loop[i][0], loop[i][1]);
      ctx.closePath();
    });
    ctx.fillStyle='#000';
    ctx.fill('evenodd');
  }

  function buildGlobalMaskAtPlane(zPlane){
  // ✅ 重要：不要把所有 mesh 的線段混在一起做 parity（會變 XOR）
  // 正確做法：每個 mesh 先各自得到 mask，再 OR union 起來（跟你原本 drawImage union 一樣）

  const unionCanvas = document.createElement('canvas');
  unionCanvas.width = frameW;
  unionCanvas.height = frameH;
  const uctx = unionCanvas.getContext('2d');

  let any = false;

  for(const m of meshes){
    const segs = [];
    collectAtPlaneForMesh(m, zPlane, segs);
    const c = rasterizeSegmentsToMaskCanvas(segs, frameW, frameH);
    if(c){
      uctx.drawImage(c, 0, 0);
      any = true;
    }
  }

  return any ? unionCanvas : null;
}

function buildPartMaskAtPlane(mesh, zPlane){
  const segs = [];
  collectAtPlaneForMesh(mesh, zPlane, segs);
  return rasterizeSegmentsToMaskCanvas(segs, frameW, frameH);
}

  const offsets=[0];

  for(let li=0; li<layerCount; li++){
    const z0=minZ + li*sliceThickness;
    const z1=Math.min(z0+sliceThickness, maxZ);
    const zMid=Math.min(maxZ, Math.max(minZ, (z0+z1)*0.5));
    const halfTh = sliceThickness*0.5;
    const zLow = Math.max(minZ, zMid - halfTh);
    const zHigh= Math.min(maxZ, zMid + halfTh);

    const unionCanvas=document.createElement('canvas'); unionCanvas.width=frameW; unionCanvas.height=frameH;
    const unionCtx=unionCanvas.getContext('2d');
    for(const off of offsets){
      const zPlane = Math.min(maxZ, Math.max(minZ, zMid+off));
      const m=buildGlobalMaskAtPlane(zPlane);
      if(m) unionCtx.drawImage(m,0,0);
    }

    const outParts=[];
    for(const m of meshes){
      const pmUnion=document.createElement('canvas'); pmUnion.width=frameW; pmUnion.height=frameH;
      const pmCtx=pmUnion.getContext('2d');
      for(const off of offsets){
        const zPlane=Math.min(maxZ, Math.max(minZ, zMid+off));
        const pm=buildPartMaskAtPlane(m,zPlane);
        if(pm) pmCtx.drawImage(pm,0,0);
      }
      pmCtx.globalCompositeOperation='destination-in';
      pmCtx.drawImage(unionCanvas,0,0);
      pmCtx.globalCompositeOperation='source-over';
      const pid = getRootPartIdForMesh(m);
      outParts.push({ mask:pmUnion, x:0, y:0, w:frameW, h:frameH, color:getMeshDisplayColor(m), partId: pid });
    }

    baseSlices.push({
      frameW,frameH,
      mask:unionCanvas, x:0, y:0, w:frameW, h:frameH,
      parts: outParts, analysis:null, partAnalyses:new Map(),
      zMid, zLow, zHigh
    });
    layerSettings.push(defLayerSetting());
    showProgress(`切片中… (${li+1}/${layerCount})`, (li+1)/layerCount * 0.9);
    if(li%1===0) await nextFrame();
  }

  updateLayerInfo(1, baseSlices.length);
  currentSliceIndex=0;
  buildLayerList(baseSlices.length);
  scheduleRenderSlice(currentSliceIndex);
  document.getElementById('export-all-folder').disabled = (baseSlices.length===0);
  layoutSliceCanvas();
  syncLayerSlider();

  growthSlider.min=0; growthSlider.max=String(baseSlices.length); growthSlider.value="0";
  growthInput.min=0;  growthInput.max=String(baseSlices.length);

  showProgress('完成', 1);
  await nextFrame();
  hideProgress();
}

/* 預設層設定 */
function defLayerSetting(){
  return {
    color: defaultSliceColor || '#e74c3c',
    gray2Enabled:false,
    gray2Steps:5,
    gray2Mode:'edge-in',
    pixelLevel:0,
    _ver:0
  };
}

/* 右側清單小色塊：直接用實際合成 */
function drawLayerSwatchCanvas(canvas, i){
  const ctx = canvas.getContext('2d', { willReadFrequently:true });
  ctx.clearRect(0,0,canvas.width,canvas.height);
  if(!baseSlices[i]) return;

  const full = compositeLayerToCanvas(i, {transparent:false, includeScaleBar:false});
  if(!full) return;
  ctx.imageSmoothingEnabled=true;
  ctx.drawImage(full, 0,0, full.width, full.height, 0,0, canvas.width, canvas.height);
}

function layerMetaText(i){
  const st = ensureLayerSettings(i);
  let hasNewerPart = false;
  for(const [k,v] of partSliceSettings){
    const [L] = k.split(':'); if(Number(L)!==i) continue;
    if((v?._ver||-1) >= (st._ver||0)){ hasNewerPart = true; break; }
  }
  if((st._ver||0)>0 && !hasNewerPart) return '全層覆蓋';
  if(hasNewerPart && (st._ver||0)===0) return '個別覆蓋';
  if(hasNewerPart && (st._ver||0)>0) return '混合';
  return usePartColorsChk.checked ? '多色（檔案）' : '單色（層色）';
}

function buildLayerList(count){
  const list = document.getElementById('layers-list'); list.innerHTML='';
  for(let i=0;i<count;i++){
    const item=document.createElement('div'); item.className='layer-item';
    if(i===currentSliceIndex) item.classList.add('active');

    const left=document.createElement('div'); left.className='layer-left';
    const title=document.createElement('div'); title.className='layer-title'; title.textContent=`第 ${i+1} 層`;
    const meta=document.createElement('div'); meta.className='layer-meta'; meta.textContent = layerMetaText(i);
    left.appendChild(title); left.appendChild(meta);

    const right=document.createElement('div'); right.className='layer-right';
    const wrap=document.createElement('div'); wrap.className='swatch-wrap';
    const swatch=document.createElement('canvas'); swatch.className='color-swatch'; swatch.width=18; swatch.height=18;
    const colorInput=document.createElement('input'); colorInput.type='color'; colorInput.className='color-input-overlay';
    colorInput.value=(ensureLayerSettings(i).color)||(defaultSliceColor||'#e74c3c');
    colorInput.disabled=false;
    colorInput.addEventListener('input',(ev)=>{
      ensureLayerSettings(i).color = ev.target.value;
      bumpLayerVersion(i);
      if(i===currentSliceIndex) uiColor.value = ev.target.value;
      drawLayerSwatchCanvas(swatch, i); scheduleRenderSlice(currentSliceIndex);
      meta.textContent = layerMetaText(i);
    });
    drawLayerSwatchCanvas(swatch, i);
    wrap.appendChild(swatch); wrap.appendChild(colorInput); right.appendChild(wrap);

    item.appendChild(left); item.appendChild(right);
    item.addEventListener('click', ()=>{
      setTab('slice');
      scheduleRenderSlice(i);
      highlightLayerInList(i);
    });
    list.appendChild(item);
  }
}
function syncLayerSlider(){
  if(baseSlices.length>0){
    const max = baseSlices.length;
    layerSlider.min=1; layerSlider.max=max;
    layerSlider.value = currentSliceIndex+1;

    if(slicePlaySlider){
      slicePlaySlider.min = 1;
      slicePlaySlider.max = max;
      slicePlaySlider.value = currentSliceIndex+1;
    }

    if(document.getElementById('slice-tab').classList.contains('active'))
      layerSlider.style.display='block';
  }else{
    layerSlider.style.display='none';
    if(slicePlaySlider){
      slicePlaySlider.min=1; slicePlaySlider.max=1; slicePlaySlider.value=1;
    }
  }
}
function highlightLayerInList(index){
  currentSliceIndex=index;
  const items=document.querySelectorAll('.layer-item');
  items.forEach((el,i)=>{ if(i===index) el.classList.add('active'); else el.classList.remove('active'); });

  const st=ensureLayerSettings(index);
  uiColor.value = st.color;

  uiGray2Enable.checked = !!st.gray2Enabled;
  uiGray2Steps.disabled = !st.gray2Enabled;
  uiGray2Mode.disabled  = !st.gray2Enabled;
  uiGray2Steps.value    = String(st.gray2Steps);
  uiGray2StepsLabel.textContent = String(st.gray2Steps);
  uiGray2Mode.value     = st.gray2Mode;

  uiPixel.value = String(st.pixelLevel);
  syncLayerSlider();
}

/* 渲染單層 */
function renderSlice(index, fast=false){
  if(index<0 || index>=baseSlices.length) return;
  currentSliceIndex=index;
  updateLayerInfo(index+1, baseSlices.length);
  highlightLayerInList(index);

  const c = compositeLayerToCanvas(index, {transparent:false, includeScaleBar:true});
  if(!c) return;

  sliceCanvas.width = c.width;
  sliceCanvas.height = c.height;
  sliceCtx.clearRect(0,0,c.width,c.height);
  sliceCtx.drawImage(c,0,0);

  layoutSliceCanvas();
  updateActiveLayerSwatchCanvas();
  syncLayerSlider();
  updateLayerSliderPosition();
}
function updateActiveLayerSwatchCanvas(){
  const item=document.querySelectorAll('.layer-item')[currentSliceIndex];
  if(!item) return; const swatch=item.querySelector('canvas.color-swatch'); if(!swatch) return;
  drawLayerSwatchCanvas(swatch, currentSliceIndex);
}

/* 比例尺 */
function drawScaleBar(ctx, w,h){
  if(!scaleBarEnabled) return;
  const pxPerUnit = pxPerUnitScaleBar || pxPerUnitGlobal || 1;
  const margin=16; const targetPx=Math.max(60, Math.min(0.25*w, 240));
  const targetUnits=targetPx/pxPerUnit;
  const pow=Math.floor(Math.log10(targetUnits||1));
  const bases=[1,2,5]; let bestUnits=bases[0]*Math.pow(10,pow), bestDiff=Infinity;
  for(const b of bases){
    const u=b*Math.pow(10,pow); const diff=Math.abs(u-targetUnits);
    if(diff<bestDiff){bestDiff=diff; bestUnits=u;}
  }
  let labelValue=bestUnits, unitStr='mm';
  if(bestUnits>=1000){ labelValue=bestUnits/1000; unitStr='m'; }
  else if(bestUnits>=10){ labelValue=bestUnits/10; unitStr='cm'; }
  let barPx=bestUnits*pxPerUnit; barPx=Math.max(40, Math.min(barPx, w-margin*2));

  const barH=6; const x=margin, y=h-margin-barH;

  ctx.save();
  ctx.fillStyle='rgba(255,255,255,0.95)';
  ctx.fillRect(x-10, y-22, barPx+20, 34);
  ctx.strokeStyle='rgba(0,0,0,0.2)'; ctx.lineWidth=1;
  ctx.strokeRect(x-10, y-22, barPx+20, 34);

  ctx.fillStyle='#111827'; ctx.fillRect(x,y,barPx,barH);

  ctx.strokeStyle='#111827'; ctx.lineWidth=2; ctx.beginPath();
  ctx.moveTo(x,y); ctx.lineTo(x,y-8);
  ctx.moveTo(x+barPx,y); ctx.lineTo(x+barPx,y-8);
  ctx.stroke();

  ctx.lineWidth=1; ctx.beginPath();
  for(let k=1;k<4;k++){
    const tx=x+(barPx*k/4);
    ctx.moveTo(tx,y); ctx.lineTo(tx,y-4);
  }
  ctx.stroke();

  const label=`${(Math.round(labelValue*100)/100)} ${unitStr}`;
  ctx.font='12px system-ui, Arial'; const textW=ctx.measureText(label).width;
  const tx=x+barPx/2-textW/2, ty=y-10;
  ctx.fillStyle='#111827'; ctx.fillText(label, tx, ty);
  ctx.restore();
}

/* 層設定事件 */
uiColor.addEventListener('input', ()=>{
  if(!baseSlices.length) return;
  const st=ensureLayerSettings(currentSliceIndex);
  st.color = uiColor.value; bumpLayerVersion(currentSliceIndex);
  scheduleRenderSlice(currentSliceIndex, isInteracting);
  const items=document.querySelectorAll('.layer-item'); if(items[currentSliceIndex]) items[currentSliceIndex].querySelector('.layer-meta').textContent=layerMetaText(currentSliceIndex);
});
uiGray2Enable.addEventListener('change', ()=>{
  const st=ensureLayerSettings(currentSliceIndex);
  st.gray2Enabled = uiGray2Enable.checked; bumpLayerVersion(currentSliceIndex);
  uiGray2Steps.disabled = !st.gray2Enabled; uiGray2Mode.disabled  = !st.gray2Enabled;
  scheduleRenderSlice(currentSliceIndex);
  const items=document.querySelectorAll('.layer-item'); if(items[currentSliceIndex]) items[currentSliceIndex].querySelector('.layer-meta').textContent=layerMetaText(currentSliceIndex);
});
uiGray2Steps.addEventListener('input', ()=>{
  uiGray2StepsLabel.textContent=uiGray2Steps.value;
  const st=ensureLayerSettings(currentSliceIndex);
  st.gray2Steps=parseInt(uiGray2Steps.value,10); bumpLayerVersion(currentSliceIndex);
  scheduleRenderSlice(currentSliceIndex, true);
});
uiGray2Steps.addEventListener('change', ()=> scheduleRenderSlice(currentSliceIndex));
uiGray2Mode.addEventListener('change', ()=>{
  const st=ensureLayerSettings(currentSliceIndex);
  st.gray2Mode=uiGray2Mode.value; bumpLayerVersion(currentSliceIndex);
  scheduleRenderSlice(currentSliceIndex);
});
uiPixel.addEventListener('input', ()=>{
  if(!baseSlices.length) return;
  ensureLayerSettings(currentSliceIndex).pixelLevel=parseInt(uiPixel.value||'0',10); bumpLayerVersion(currentSliceIndex);
  scheduleRenderSlice(currentSliceIndex, true);
});
uiPixel.addEventListener('change', ()=> scheduleRenderSlice(currentSliceIndex));
toggleScaleBar.addEventListener('change', ()=>{
  scaleBarEnabled=toggleScaleBar.checked;
  updateLayerSliderPosition();
  if(baseSlices.length>0) scheduleRenderSlice(currentSliceIndex);
});

/* 多色基色來源提示 */
usePartColorsChk.addEventListener('change', ()=>{
  colorHint.textContent = usePartColorsChk.checked
    ? '基色來源：檔案（多色）。仍可自訂零件或全層；後改者優先。'
    : '基色來源：層色（單色）。仍可自訂零件或全層；後改者優先。';
  if(baseSlices.length>0) scheduleRenderSlice(currentSliceIndex);
});

/* 平台套用 */
document.getElementById('apply-platform').addEventListener('click', ()=>{
  platform.width = Math.max(1, parseFloat(plateWInput.value)||platform.width);
  platform.height= Math.max(1, parseFloat(plateHInput.value)||platform.height);
  updatePlatformVisual();
  syncExportFromWidth(); // 依新平台比例更新輸出尺寸與比例尺
  growthBuilt=false;
  if(baseSlices.length>0){ generateSlices(); }
});

/* 將目前層設定套用至所有層 */
document.getElementById('apply-to-all').addEventListener('click', async ()=>{
  if(baseSlices.length===0) return;
  const i=currentSliceIndex; const src=ensureLayerSettings(i);
  const total = layerSettings.length;

  const overrides = [];
  for(const [key, val] of partSliceSettings.entries()){
    const [layerStr, pidStr] = key.split(':');
    if(parseInt(layerStr,10) === i){
      overrides.push([Number(pidStr), {...val}]);
    }
  }

  showProgress(`套用目前層設定中… (0/${total})`, 0);
  await nextFrame();

  const newVer = ++verSeq;
  for(let k=0;k<layerSettings.length;k++){
    layerSettings[k]={
      color:src.color,
      gray2Enabled:src.gray2Enabled,
      gray2Steps:src.gray2Steps,
      gray2Mode:src.gray2Mode,
      pixelLevel:src.pixelLevel,
      _ver:newVer
    };

    overrides.forEach(([pid, st])=>{
      partSliceSettings.set(`${k}:${pid}`, {...st, _ver:newVer});
    });

    const p = 0.90 * (k+1)/total;
    showProgress(`套用目前層設定中… (${k+1}/${total})`, p);
    await nextFrame();
  }

  showProgress('重建預覽清單…', 0.92);
  await nextFrame();
  buildLayerList(layerSettings.length);

  const items=document.querySelectorAll('.layer-item');
  for(let j=0;j<items.length;j++){
    const swatch=items[j].querySelector('canvas.color-swatch');
    if(swatch) drawLayerSwatchCanvas(swatch, j);
    const p = 0.92 + 0.075*((j+1)/Math.max(1,items.length));
    showProgress('重建預覽…', Math.min(0.995, p));
    await nextFrame();
  }

  scheduleRenderSlice(i);
  showProgress('完成', 1);
  await nextFrame();
  hideProgress();
});

/* 切片與導覽 */
document.getElementById('slice-button').addEventListener('click', ()=> generateSlices());
document.getElementById('prev-layer').addEventListener('click', ()=>{
  if(currentSliceIndex>0){
    setTab('slice');
    scheduleRenderSlice(currentSliceIndex-1);
  }
});
document.getElementById('next-layer').addEventListener('click', ()=>{
  if(currentSliceIndex<baseSlices.length-1){
    setTab('slice');
    scheduleRenderSlice(currentSliceIndex+1);
  }
});
document.getElementById('first-layer').addEventListener('click', ()=>{
  setTab('slice');
  scheduleRenderSlice(0);
});
document.getElementById('last-layer').addEventListener('click', ()=>{
  setTab('slice');
  scheduleRenderSlice(baseSlices.length-1);
});
layerSlider.addEventListener('pointerdown', ()=>{ isInteracting=true; });
window.addEventListener('pointerup', ()=>{
  if(isInteracting){
    isInteracting=false;
    scheduleRenderSlice(currentSliceIndex);
  }
});
layerSlider.addEventListener('input', ()=>{
  const v=parseInt(layerSlider.value||'1',10);
  if(!isNaN(v)){
    setTab('slice');
    scheduleRenderSlice(v-1, true);
  }
});
if(slicePlaySlider){
  slicePlaySlider.addEventListener('input', ()=>{
    const v = parseInt(slicePlaySlider.value||'1',10);
    if(!isNaN(v)){
      setTab('slice');
      scheduleRenderSlice(v-1, true);
    }
  });
}

/* 匯出 */
function renderLayerFullFrame(i){
  const c = compositeLayerToCanvas(i, {transparent:false, includeScaleBar:false});
  return c;
}
function renderLayerRect(i, outW, outH){
  const src=renderLayerFullFrame(i);
  const SW=src.width, SH=src.height;
  const W=Math.max(8, outW|0 || 2048);
  const H=Math.max(8, outH|0 || 2048);
  const out=document.createElement('canvas'); out.width=W; out.height=H;
  const octx=out.getContext('2d'); octx.fillStyle='#ffffff'; octx.fillRect(0,0,W,H);
  octx.imageSmoothingEnabled=true;
  octx.drawImage(src,0,0,SW,SH, 0,0,W,H);
  const scaledDown = (W < SW || H < SH);
  return {canvas:out, scaledDown};
}
function pickMimeExtSafe(requested){
  const want=(req)=> req==='bmp'?{mime:'image/bmp',ext:'bmp'}: req==='jpg'?{mime:'image/jpeg',ext:'jpg'}:{mime:'image/png',ext:'png'};
  const w=want(requested);
  try{
    const test=document.createElement('canvas'); test.width=test.height=2;
    const dataURL=test.toDataURL(w.mime);
    if(dataURL.startsWith(`data:${w.mime}`)) return {...w,fallback:false};
  }catch(_){}
  return {mime:'image/png', ext:'png', fallback:true};
}
function canvasToBmpBlob(canvas){
  const w = canvas.width|0, h = canvas.height|0;
  const ctx = canvas.getContext('2d');
  const imageData = ctx.getImageData(0,0,w,h).data;
  const rowSize = w * 3;
  const rowPadding = (4 - (rowSize % 4)) % 4;
  const dataSize = (rowSize + rowPadding) * h;
  const fileSize = 54 + dataSize;

  const buffer = new ArrayBuffer(fileSize);
  const dv = new DataView(buffer);

  dv.setUint8(0,0x42);
  dv.setUint8(1,0x4d);
  dv.setUint32(2,fileSize,true);
  dv.setUint32(6,0,true);
  dv.setUint32(10,54,true);

  dv.setUint32(14,40,true);
  dv.setInt32(18,w,true);
  dv.setInt32(22,-h,true);
  dv.setUint16(26,1,true);
  dv.setUint16(28,24,true);
  dv.setUint32(30,0,true);
  dv.setUint32(34,dataSize,true);
  dv.setInt32(38,2835,true);
  dv.setInt32(42,2835,true);
  dv.setUint32(46,0,true);
  dv.setUint32(50,0,true);

  let offset = 54;
  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      const idx = (y*w + x)*4;
      const r = imageData[idx];
      const g = imageData[idx+1];
      const b = imageData[idx+2];
      dv.setUint8(offset++, b);
      dv.setUint8(offset++, g);
      dv.setUint8(offset++, r);
    }
    for(let p=0;p<rowPadding;p++) dv.setUint8(offset++, 0);
  }

  return new Blob([buffer], {type:'image/bmp'});
}

document.getElementById('export-button').addEventListener('click', ()=>{
  if(baseSlices.length===0) return;
  const i=currentSliceIndex;
  const sizes = getExportSizes();
  const {canvas:out, scaledDown}=renderLayerRect(i, sizes.width, sizes.height);
  const type=document.getElementById('export-type').value;

  if(type === 'bmp'){
    if(scaledDown) alert('原始切片尺寸超過輸出尺寸，已等比例縮小。');
    const blob = canvasToBmpBlob(out);
    const url=URL.createObjectURL(blob);
    const a=document.createElement('a'); a.href=url; a.download=`slice_${i+1}.bmp`;
    document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
    return;
  }

  const {mime,ext,fallback}=pickMimeExtSafe(type);
  if(fallback) alert(`瀏覽器不支援 ${type.toUpperCase()}，已自動改為 PNG。`);
  if(scaledDown) alert('原始切片尺寸超過輸出尺寸，已等比例縮小。');

  out.toBlob(blob=>{
    const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=`slice_${i+1}.${ext}`;
    document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
  }, mime);
});

document.getElementById('export-all-folder').addEventListener('click', async ()=>{
  if(!('showDirectoryPicker' in window)){ alert('此瀏覽器不支援「存到資料夾」。請用 Chrome / Edge。'); return; }
  if(baseSlices.length===0){ alert('尚未產生切片'); return; }
  const type=document.getElementById('export-type').value;
  const sizes = getExportSizes();
  const parent=await window.showDirectoryPicker({id:'slices_out', mode:'readwrite'});
  const defaultFolderName=sanitizeName(`${modelBaseName}_slices`);
  const userInput=window.prompt('輸出資料夾名稱（可修改）：', defaultFolderName);
  const baseFolderName=sanitizeName(userInput || defaultFolderName);
  async function ensureUniqueSubfolder(parentHandle, baseName){
    let name=baseName, i=1;
    while(true){
      try{
        const h=await parentHandle.getDirectoryHandle(name,{create:true});
        return {name, handle:h};
      }catch(e){
        name=`${baseName}_${(++i)}`;
        if(i>200) throw new Error('無法建立輸出資料夾（名稱衝突過多）');
      }
    }
  }
  const {name:actualFolderName, handle:outDir}=await ensureUniqueSubfolder(parent, baseFolderName);
  const pad=String(baseSlices.length).length; const fileBase=sanitizeName(baseFolderName);
  let anyScaled=false;

  if(type === 'bmp'){
    const ext='bmp';
    for(let i=0;i<baseSlices.length;i++){
      const {canvas:out, scaledDown}=renderLayerRect(i, sizes.width, sizes.height); if(scaledDown) anyScaled=true;
      const blob = canvasToBmpBlob(out);
      const idx=String(i+1).padStart(pad,'0'); const fileName=`${fileBase}_${idx}.${ext}`;
      const fh=await outDir.getFileHandle(fileName,{create:true}); const w=await fh.createWritable(); await w.write(blob); await w.close();
    }
    const msg=(actualFolderName===baseFolderName)?`已寫入到資料夾「${actualFolderName}」。`:`偵測到同名資料夾，已改存為「${actualFolderName}」。`;
    alert(msg + (anyScaled?'\n部分切片原尺寸超過輸出尺寸，已等比例縮小。':''));
    return;
  }

  const {mime,ext,fallback}=pickMimeExtSafe(type); if(fallback) alert(`瀏覽器不支援 ${type.toUpperCase()}，已自動改為 PNG。`);
  for(let i=0;i<baseSlices.length;i++){
    const {canvas:out, scaledDown}=renderLayerRect(i, sizes.width, sizes.height); if(scaledDown) anyScaled=true;
    const blob=await new Promise(res=> out.toBlob(res, mime));
    const idx=String(i+1).padStart(pad,'0'); const fileName=`${fileBase}_${idx}.${ext}`;
    const fh=await outDir.getFileHandle(fileName,{create:true}); const w=await fh.createWritable(); await w.write(blob); await w.close();
  }
  const msg=(actualFolderName===baseFolderName)?`已寫入到資料夾「${actualFolderName}」。`:`偵測到同名資料夾，已改存為「${actualFolderName}」。`;
  alert(msg + (anyScaled?'\n部分切片原尺寸超過輸出尺寸，已等比例縮小。':''));
});

/* 頁籤切換 */
document.getElementById('model-tab').addEventListener('click', ()=> setTab('model'));
document.getElementById('slice-tab').addEventListener('click', ()=> setTab('slice'));
document.getElementById('growth-tab').addEventListener('click', ()=> setTab('growth'));
function resetInteractiveUi(){
  const marquee = document.getElementById('marquee');
  marquee.style.display='none';
  isDraggingPart=false;
  controls.enabled=true;
}
function setTab(tab){
  const modelTab=document.getElementById('model-tab');
  const sliceTab=document.getElementById('slice-tab');
  const growthTab=document.getElementById('growth-tab');
  const modelCanvas=document.getElementById('model-canvas');

  modelTab.classList.remove('active'); sliceTab.classList.remove('active'); growthTab.classList.remove('active');

  activeTab = tab;
  resetInteractiveUi();
  updateBoxToggleUI();

  if(tab==='model'){
    modelTab.classList.add('active'); modelCanvas.style.display='block'; sliceCanvas.style.display='none'; layerSlider.style.display='none';
    hud.style.display='none';
    if(model) model.visible=true;
    stopGrowth();
    growthGroup.visible=false;
    unloadAllGrowthTextures();
    updatePartsHelpers();
    partFly.style.display='none';
    platformOverlay.style.display='block';
    miniAxesCanvas.style.display = 'block';
    axesOverlayCanvas.style.display = 'block';
    slicePlayOverlay.style.display = 'none';
    stopSlicePlay(true);
  }else if(tab==='slice'){
    sliceTab.classList.add('active'); sliceCanvas.style.display='block'; modelCanvas.style.display='none';
    hud.style.display='none';
    scheduleRenderSlice(currentSliceIndex);
    layoutSliceCanvas(); syncLayerSlider();
    stopGrowth(); growthGroup.visible=false; unloadAllGrowthTextures();
    parts.forEach(p=> p.helper.visible=false);
    partFly.style.display='none';
    platformOverlay.style.display='none';
    miniAxesCanvas.style.display = 'none';
    axesOverlayCanvas.style.display = 'none';
    slicePlayOverlay.style.display = baseSlices.length>0 ? 'block' : 'none';
  }else{
    growthTab.classList.add('active'); modelCanvas.style.display='block'; sliceCanvas.style.display='none'; layerSlider.style.display='none';
    if(model) model.visible=false;
    ensureGrowthBuilt();
    growthGroup.visible = true;

    // ★ 進入成長視圖：預設顯示完整（避免看起來像沒切到）
    //    想看從 0 長出來：按「停止」或把滑桿拉回 0
    if (baseSlices.length > 0) {
      if (growthShownLayers === 0) setGrowthShownLayers(baseSlices.length);
      else setGrowthShownLayers(growthShownLayers);
    }

    
    parts.forEach(p=> p.helper.visible=false);
    partFly.style.display='none';
    platformOverlay.style.display='none';
    miniAxesCanvas.style.display = 'block';
    axesOverlayCanvas.style.display = 'block';
    slicePlayOverlay.style.display = 'none';
    stopSlicePlay(true);
  }
}

/* 成長視圖 */
function growthTexDims(i){
  if(i<0 || i>=baseSlices.length) return [1,1];
  const rec=baseSlices[i]; const SW=rec.frameW, SH=rec.frameH;
  const maxSide=Math.max(SW,SH);
  if(maxSide<=GROWTH_MAX_TEX) return [SW,SH];
  const s=GROWTH_MAX_TEX/maxSide;
  return [Math.max(1,Math.round(SW*s)), Math.max(1,Math.round(SH*s))];
}
function renderLayerTextureCanvas(i){
  return compositeLayerToCanvas(i, {transparent:true, includeScaleBar:false});
}
function makeGrowthTextureCanvas(i){
  const src=renderLayerTextureCanvas(i);
  const [tw,th]=growthTexDims(i);
  if(src.width===tw && src.height===th) return src;
  const dst=document.createElement('canvas'); dst.width=tw; dst.height=th;
  const dctx=dst.getContext('2d'); dctx.imageSmoothingEnabled=true; dctx.drawImage(src,0,0,src.width,src.height, 0,0,tw,th);
  return dst;
}
function loadGrowthTexture(i){
  if(growthLoaded.has(i)) return growthLoaded.get(i).tex;
  const canvas=makeGrowthTextureCanvas(i);
  const tex=new THREE.CanvasTexture(canvas);
  tex.flipY = false; // 修正成長視圖相對 3D 模型的上下方向
  tex.premultiplyAlpha=true; tex.generateMipmaps=false;
  tex.minFilter=THREE.LinearFilter; tex.magFilter=THREE.LinearFilter;
  tex.wrapS=tex.wrapT=THREE.ClampToEdgeWrapping; tex.needsUpdate=true;

  const [tw,th]=growthTexDims(i); const bytes=tw*th*4;
  growthLoaded.set(i,{tex,bytes});
  const g=growthGroup.children[i];
  if(g){
    g.userData.bottom.material.map=tex;
    g.userData.top.material.map=tex;
    g.userData.bottom.material.needsUpdate=true;
    g.userData.top.material.needsUpdate=true;
  }
  return tex;
}
function unloadGrowthTexture(i){
  const rec=growthLoaded.get(i); if(!rec) return;
  try{ rec.tex.dispose(); }catch(_){}
  const g=growthGroup.children[i];
  if(g){
    g.userData.bottom.material.map=null;
    g.userData.top.material.map=null;
    g.userData.bottom.material.needsUpdate=true;
    g.userData.top.material.needsUpdate=true;
  }
  growthLoaded.delete(i);
}
function unloadAllGrowthTextures(){
  for(const k of Array.from(growthLoaded.keys())) unloadGrowthTexture(k);
}
function disposeGrowthGroup(){
  if(!growthGroup) return;
  unloadAllGrowthTextures();
  growthGroup.children.forEach(g=>{
    if(g.userData?._dispose) try{ g.userData._dispose(); }catch(_){}
  });
}

function ensureGrowthBuilt(){
  if(growthBuilt || baseSlices.length===0) return;
  const width = platform.width;
  const height = platform.height;
  const cx = 0, cy = 0;
  const geo = new THREE.PlaneGeometry(width, height);

  for(let i=0;i<baseSlices.length;i++){
    const rec = baseSlices[i];
    const zLow  = rec.zLow  != null ? rec.zLow  : (sliceBounds.zMin + i*sliceThickness);
    const zHigh = rec.zHigh != null ? rec.zHigh : (sliceBounds.zMin + (i+1)*sliceThickness);

    const matBottom=new THREE.MeshBasicMaterial({transparent:true,opacity:1,side:THREE.DoubleSide,depthWrite:true,depthTest:true});
    const matTop   =new THREE.MeshBasicMaterial({transparent:true,opacity:1,side:THREE.DoubleSide,depthWrite:true,depthTest:true});
    const bottom=new THREE.Mesh(geo, matBottom);
    const top   =new THREE.Mesh(geo, matTop);
    bottom.position.set(cx, cy, zLow +0.0005);
    top.position.set   (cx, cy, zHigh-0.0005);

    const g=new THREE.Group();
    g.userData.bottom=bottom;
    g.userData.top=top;
    g.add(bottom); g.add(top);
    g.visible=false;
    g.userData._dispose=()=>{
      try{matBottom.map?.dispose();}catch(_){}
      try{matTop.map?.dispose();}catch(_){}
      try{matBottom.dispose(); matTop.dispose();}catch(_){}
    };
    growthGroup.add(g);
  }
  setGrowthShownLayers(0);
  growthBuilt=true;
}

function setGrowthShownLayers(n){
  if(!growthGroup) return;
  const total=growthGroup.children.length;
  let val=Math.max(0, Math.min(total, Number(n)||0)); growthShownLayers=val;
  const whole=Math.floor(val), frac=val - whole;
  for(let i=0;i<total;i++){
    const g=growthGroup.children[i];
    if(i<whole){
      g.visible=true; loadGrowthTexture(i);
      g.userData.bottom.material.opacity=1;
      g.userData.top.material.opacity=1;
    }else if(i===whole && frac>0 && i<total){
      g.visible=true; loadGrowthTexture(i);
      g.userData.bottom.material.opacity=frac;
      g.userData.top.material.opacity=frac;
    }else{
      g.visible=false;
    }
  }
  growthSlider.value=String(whole);
  growthInput.value=String(whole);
  updateGrowthResident(whole);
}
function updateGrowthResident(centerIndex){
  if(!growthGroup || !growthGroup.children.length) return;
  const visibleMax=Math.max(0, Math.min(growthShownLayers, growthGroup.children.length-1));
  const [tw,th]=growthTexDims(Math.min(centerIndex, growthGroup.children.length-1));
  const bytesPerTex=Math.max(1, tw*th*4);
  const cap=Math.max(16, Math.floor((GROWTH_RESIDENT_TARGET_MB*1024*1024)/bytesPerTex));
  const half=Math.max(8, Math.floor(cap/2)-1);
  const hiWindow=Math.min(growthGroup.children.length-1, centerIndex+half);
  const keepHi=Math.max(visibleMax, hiWindow);
  for(let i=0;i<=keepHi;i++) loadGrowthTexture(i);
  for(const k of Array.from(growthLoaded.keys())){
    if(k>keepHi) unloadGrowthTexture(k);
  }
}
function startGrowth(target=null){
  if(growthPlaying) return;
  growthPlaying=true;
  let last=null;
  growthRAF=requestAnimationFrame(function tick(ts){
    if(!growthPlaying) return;
    if(last==null) last=ts;
    const dt=(ts-last)/1000; last=ts;
    const spd=Math.max(0.1, parseFloat(growthSpeedInput.value)||5);
    let next=growthShownLayers + spd*dt;
    const goal = (target==null)? baseSlices.length : Math.max(0,Math.min(baseSlices.length, target));
    if(next>=goal){
      next=goal;
      setGrowthShownLayers(next);
      stopGrowth();
      return;
    }
    setGrowthShownLayers(next);
    growthRAF=requestAnimationFrame(tick);
  });
}
function stopGrowth(){
  if(growthRAF){
    cancelAnimationFrame(growthRAF);
    growthRAF=0;
  }
  growthPlaying=false;
}

growthAnimateBtn.addEventListener('click', ()=>{
  if(!growthBuilt) ensureGrowthBuilt();
  if(growthPlaying) stopGrowth();
  else startGrowth(null);
});
growthStopBtn.addEventListener('click', ()=>{
  stopGrowth();
  setGrowthShownLayers(0);
});
growthSlider.addEventListener('input', ()=>{
  const v=parseInt(growthSlider.value||'0',10);
  if(!isNaN(v)){
    stopGrowth();
    setGrowthShownLayers(v);
  }
});
growthInput.addEventListener('change', ()=>{
  const v=parseInt(growthInput.value||'0',10);
  if(!isNaN(v)){
    stopGrowth();
    setGrowthShownLayers(v);
  }
});
document.getElementById('growth-play-to-target').addEventListener('click', ()=>{
  const tgt=Math.max(0, Math.min(baseSlices.length, parseInt(growthInput.value||'0',10)||0));
  stopGrowth();
  setGrowthShownLayers(0);
  startGrowth(tgt);
});

/* 置中/貼地 & 原位 */
document.getElementById('reset-transform').addEventListener('click', ()=> groundAll());
document.getElementById('center-model').addEventListener('click', ()=>{
  const any=getSelectedParts().length>0;
  resetToOriginal(any);
});

/* 刪除選取零件 */
document.getElementById('delete-selected').addEventListener('click', deleteSelected);

/* 佈局 */
function layoutSliceCanvas(){
  const wrap=document.querySelector('.canvas-wrap');
  if(!wrap || sliceCanvas.style.display==='none') return;
  const pad=16;
  const vw=wrap.clientWidth-pad*2;
  const vh=wrap.clientHeight-pad*2;
  const cw=frameWGlobal||sliceCanvas.width||1;
  const ch=frameHGlobal||sliceCanvas.height||1;
  const basisW=cw, basisH=ch;
  const scale=Math.min(vw/basisW, vh/basisH);
  sliceCanvas.style.transform = `translate(-50%,-50%) scale(${scale})`;
}

/* 切片視圖：點擊零件開啟 per-part 視窗 */
sliceCanvas.addEventListener('click', (ev)=>{
  if(activeTab!=='slice' || !baseSlices.length) return;
  const rec = baseSlices[currentSliceIndex];
  const rect = sliceCanvas.getBoundingClientRect();
  const cx = (ev.clientX - rect.left) * (sliceCanvas.width / rect.width);
  const cy = (ev.clientY - rect.top)  * (sliceCanvas.height / rect.height);

  for(let k=rec.parts.length-1;k>=0;k--){
    const p = rec.parts[k];
    if(cx< p.x || cy< p.y || cx>=p.x+p.w || cy>=p.y+p.h) continue;
    const px = Math.floor(cx - p.x), py = Math.floor(cy - p.y);
    const d = p.mask.getContext('2d').getImageData(px,py,1,1).data;
    if(d[3]>0){
      openPartFly(currentSliceIndex, p.partId, p);
      return;
    }
  }
  partFly.style.display='none';
});

function openPartFly(layerIndex, pid, part){
  const key = `${layerIndex}:${pid}`;
  const def = effectiveStyleForPart(layerIndex, part);
  const cur = partSliceSettings.get(key);
  const st = cur || {
    color: def.color || '#e74c3c',
    gray2Enabled:false, gray2Steps:5, gray2Mode:'edge-in',
    pixelLevel:0, _ver:0
  };
  pfColor.value = st.color || '#e74c3c';
  pfGrayEnable.checked = !!st.gray2Enabled;
  pfSteps.disabled = !pfGrayEnable.checked;
  pfMode.disabled  = !pfGrayEnable.checked;
  pfSteps.value = String(st.gray2Steps||5);
  pfStepsLab.textContent = pfSteps.value;
  pfMode.value = st.gray2Mode || 'edge-in';
  pfPixel.value = String(st.pixelLevel||0);

  partFlyTitle.textContent = `零件 ${pid} — 第 ${layerIndex+1} 層`;
  partFly.style.display='block';

  const applyNow = ()=>{
    const obj = partSliceSettings.get(key) || {};
    obj.color = pfColor.value;
    obj.gray2Enabled = pfGrayEnable.checked;
    obj.gray2Steps = parseInt(pfSteps.value,10)||5;
    obj.gray2Mode = pfMode.value;
    obj.pixelLevel = parseInt(pfPixel.value,10)||0;
    bumpPartVersion(key);
    const ver = (partSliceSettings.get(key)?._ver)||verSeq;
    partSliceSettings.set(key, {...obj, _ver: ver});
    scheduleRenderSlice(layerIndex, true);
    const items=document.querySelectorAll('.layer-item'); if(items[layerIndex]) items[layerIndex].querySelector('.layer-meta').textContent=layerMetaText(layerIndex);
  };

  pfColor.oninput = applyNow;
  pfGrayEnable.onchange = ()=>{
    pfSteps.disabled=!pfGrayEnable.checked;
    pfMode.disabled=!pfGrayEnable.checked;
    applyNow();
  };
  pfSteps.oninput = ()=>{
    pfStepsLab.textContent=pfSteps.value;
    applyNow();
  };
  pfMode.onchange = applyNow;
  pfPixel.oninput = applyNow;
}
partFlyClose.addEventListener('click', ()=> partFly.style.display='none');

/* 切片播放控制 */
function startSlicePlay(){
  if(slicePlaying || baseSlices.length===0) return;
  slicePlaying = true;
  slicePlayPos = currentSliceIndex;

  let last = null;
  slicePlayRAF = requestAnimationFrame(function tick(ts){
    if(!slicePlaying) return;
    if(last == null) last = ts;
    const dt = (ts - last) / 1000;
    last = ts;

    const speed = Math.max(0.1, parseFloat(slicePlaySpeedInput.value)||5);
    slicePlayPos += dt * speed;
    const maxIndex = baseSlices.length;
    if(slicePlayPos >= maxIndex) slicePlayPos = 0;

    const idx = Math.floor(slicePlayPos);
    if(idx !== currentSliceIndex){
      scheduleRenderSlice(idx, true);
    }
    slicePlayRAF = requestAnimationFrame(tick);
  });
}
function stopSlicePlay(resetPos){
  if(slicePlayRAF){
    cancelAnimationFrame(slicePlayRAF);
    slicePlayRAF = 0;
  }
  if(resetPos) slicePlayPos = currentSliceIndex;
  slicePlaying = false;
}

if(slicePlayAnimateBtn){
  slicePlayAnimateBtn.addEventListener('click', ()=>{
    if(activeTab!=='slice') setTab('slice');
    if(slicePlaying) stopSlicePlay(false);
    else startSlicePlay();
  });
}
if(slicePlayStopBtn){
  slicePlayStopBtn.addEventListener('click', ()=>{
    stopSlicePlay(true);
  });
}

/* 播放框拖曳 */
if(slicePlayHeader){
  slicePlayHeader.addEventListener('pointerdown', (ev)=>{
    if(ev.button!==0) return;
    const wrap = document.querySelector('.canvas-wrap');
    if(!wrap) return;
    const wrapRect = wrap.getBoundingClientRect();
    const rect = slicePlayOverlay.getBoundingClientRect();

    slicePlayDragging = true;
    slicePlayPointerId = ev.pointerId;
    slicePlayOverlay.classList.add('dragging');
    slicePlayOverlay.setPointerCapture(ev.pointerId);

    const currentLeft = rect.left - wrapRect.left;
    const currentTop  = rect.top  - wrapRect.top;
    slicePlayOverlay.style.left = `${currentLeft}px`;
    slicePlayOverlay.style.top  = `${currentTop}px`;
    slicePlayOverlay.style.right='auto';
    slicePlayOverlay.style.bottom='auto';

    slicePlayDragOffset.x = ev.clientX - rect.left;
    slicePlayDragOffset.y = ev.clientY - rect.top;

    ev.preventDefault();
  });

  slicePlayOverlay.addEventListener('pointermove', (ev)=>{
    if(!slicePlayDragging || ev.pointerId!==slicePlayPointerId) return;
    const wrap = document.querySelector('.canvas-wrap');
    if(!wrap) return;
    const wrapRect = wrap.getBoundingClientRect();
    const rect = slicePlayOverlay.getBoundingClientRect();

    let nx = ev.clientX - wrapRect.left - slicePlayDragOffset.x;
    let ny = ev.clientY - wrapRect.top  - slicePlayDragOffset.y;

    const maxX = wrapRect.width  - rect.width  - 4;
    const maxY = wrapRect.height - rect.height - 4;
    nx = Math.max(4, Math.min(nx, maxX));
    ny = Math.max(4, Math.min(ny, maxY));

    slicePlayOverlay.style.left = `${nx}px`;
    slicePlayOverlay.style.top  = `${ny}px`;
  });

  slicePlayOverlay.addEventListener('pointerup', (ev)=>{
    if(!slicePlayDragging || ev.pointerId!==slicePlayPointerId) return;
    slicePlayDragging = false;
    slicePlayOverlay.classList.remove('dragging');
    try{ slicePlayOverlay.releasePointerCapture(ev.pointerId); }catch(_){}
  });
  slicePlayOverlay.addEventListener('pointerleave', (ev)=>{
    if(!slicePlayDragging || ev.pointerId!==slicePlayPointerId) return;
    slicePlayDragging = false;
    slicePlayOverlay.classList.remove('dragging');
    try{ slicePlayOverlay.releasePointerCapture(ev.pointerId); }catch(_){}
  });
}

/* 啟動 */
initThree();
updateAxisBadge();
updateLayerSliderPosition();
syncExportFromWidth(); // 初始化輸出尺寸＋比例尺

</script>

</body>
</html>

